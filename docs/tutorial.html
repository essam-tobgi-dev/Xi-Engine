<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Engine Development Tutorial - Xi Engine</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>Tutorial</h2>
            <a href="index.html" class="back-link">← Back to Home</a>
        </div>
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#getting-started">Getting Started</a></li>
            <li><a href="#ecs-architecture">ECS Architecture</a>
                <ul>
                    <li><a href="#ecs-philosophy">Why ECS?</a></li>
                    <li><a href="#ecs-entity">Entity System</a></li>
                    <li><a href="#ecs-component">Component Storage</a></li>
                    <li><a href="#ecs-world">World Manager</a></li>
                    <li><a href="#ecs-systems">System Framework</a></li>
                </ul>
            </li>
            <li><a href="#scripting-engine">Scripting Engine</a>
                <ul>
                    <li><a href="#script-why">Custom vs Embedded</a></li>
                    <li><a href="#script-compiler">Compiler Basics</a></li>
                    <li><a href="#script-values">Value System</a></li>
                    <li><a href="#script-interpreter">Interpreter Design</a></li>
                </ul>
            </li>
            <li><a href="#renderer">Rendering System</a>
                <ul>
                    <li><a href="#render-pipeline">Graphics Pipeline</a></li>
                    <li><a href="#render-pbr">PBR Lighting</a></li>
                    <li><a href="#render-shaders">Shader System</a></li>
                    <li><a href="#render-materials">Material System</a></li>
                </ul>
            </li>
            <li><a href="#physics">Physics Engine</a>
                <ul>
                    <li><a href="#physics">Fundamentals</a></li>
                    <li><a href="#physics">AABB Collision</a></li>
                    <li><a href="#physics">Sphere Collision</a></li>
                    <li><a href="#physics">Collision Response</a></li>
                    <li><a href="#physics">Rigid Body Dynamics</a></li>
                    <li><a href="#physics">Raycasting</a></li>
                </ul>
            </li>
            <li><a href="#audio">Audio System</a></li>
            <li><a href="#editor">Editor Integration</a></li>
            <li><a href="#game-loop">Putting It Together</a></li>
            <li><a href="#game-development">Game Development</a>
                <ul>
                    <li><a href="#lua-basics">Lua Scripting Basics</a></li>
                    <li><a href="#entity-scripting">Entity Scripts</a></li>
                    <li><a href="#input-handling">Input Handling</a></li>
                    <li><a href="#game-examples">Complete Examples</a></li>
                </ul>
            </li>
        </ul>
    </div>

    <div class="content">
        <h1>Game Engine Development Tutorial</h1>
        <p class="subtitle">Building a Modern Game Engine from Scratch</p>

        <section id="introduction">
            <h2>Introduction: The Philosophy of Engine Design</h2>

            <h3>What is a Game Engine?</h3>
            <p>
                A game engine is not just a collection of libraries and tools. It's an architectural framework that solves the fundamental
                problem of managing complexity in interactive real-time applications. Think of it as the operating system for your game -
                it provides abstractions, manages resources, and orchestrates the interaction between disparate systems.
            </p>

            <div class="concept-box">
                <h4>The Three Pillars of Engine Architecture</h4>
                <ol>
                    <li><strong>Data Management</strong>: How we represent and store game entities and their properties</li>
                    <li><strong>System Orchestration</strong>: How different subsystems (rendering, physics, audio) communicate and update</li>
                    <li><strong>Developer Interface</strong>: How game developers interact with the engine (scripting, editor, API)</li>
                </ol>
            </div>

            <h3>Why Build Your Own Engine?</h3>
            <p>
                Before we dive into implementation, let's address the fundamental question: why build a custom engine when Unity and Unreal exist?
            </p>

            <p>
                The answer isn't about competition - it's about <strong>understanding</strong>. Building an engine from scratch teaches you:
            </p>

            <ul>
                <li><strong>Systems thinking</strong>: How complex software architectures emerge from simple components</li>
                <li><strong>Performance optimization</strong>: Why cache-friendly data structures matter in real-time applications</li>
                <li><strong>API design</strong>: How to create intuitive, powerful interfaces for game developers</li>
                <li><strong>Problem decomposition</strong>: How to break monolithic problems into manageable subsystems</li>
            </ul>

            <h3>Our Design Goals</h3>
            <p>
                The Xi Engine is designed with several core principles in mind:
            </p>

            <div class="concept-box">
                <h4>Performance Through Data-Oriented Design</h4>
                <p>
                    Traditional Object-Oriented Programming (OOP) encourages thinking about "objects" with data and behavior bundled together.
                    This is intuitive but leads to poor cache utilization in game engines. We'll use Entity-Component-System (ECS) architecture
                    to prioritize data locality and enable efficient batch processing.
                </p>
            </div>

            <div class="concept-box">
                <h4>Modularity and Separation of Concerns</h4>
                <p>
                    Each subsystem (rendering, physics, audio, scripting) should be independent and replaceable. A change to the renderer
                    shouldn't require modifications to the physics system. We achieve this through well-defined interfaces and minimal coupling.
                </p>
            </div>

            <div class="concept-box">
                <h4>Extensibility Through Scripting</h4>
                <p>
                    Game logic should be scriptable without recompiling the engine. This enables rapid iteration and empowers non-programmers
                    to contribute to game design. We'll build a custom scripting language that integrates seamlessly with the ECS architecture.
                </p>
            </div>
        </section>

        <section id="getting-started">
            <h2>Getting Started: Prerequisites and Setup</h2>

            <h3>Required Knowledge</h3>
            <p>
                This tutorial assumes you have:
            </p>
            <ul>
                <li>Intermediate C++ knowledge (templates, smart pointers, RAII)</li>
                <li>Basic understanding of 3D graphics concepts (vectors, matrices, transformations)</li>
                <li>Familiarity with OpenGL or DirectX at a conceptual level</li>
                <li>Understanding of basic data structures (hash maps, vectors, bitsets)</li>
            </ul>

            <h3>Dependencies</h3>
            <p>
                The Xi Engine uses several libraries to handle platform-specific and low-level functionality:
            </p>

            <ul>
                <li><strong>GLFW</strong>: Cross-platform window creation and input handling</li>
                <li><strong>GLEW</strong>: OpenGL extension loader</li>
                <li><strong>GLM</strong>: Mathematics library for graphics (vectors, matrices, quaternions)</li>
                <li><strong>ImGui</strong>: Immediate-mode GUI for editor interfaces</li>
                <li><strong>OpenAL</strong>: Cross-platform 3D audio API</li>
            </ul>

            <p>
                These libraries handle the tedious platform-specific code, allowing us to focus on the engine architecture itself.
            </p>

            <h3>Project Structure</h3>
            <pre><code class="language-plaintext">Xi Engine/
├── Engine/
│   ├── Core/          # Application, Window, Input
│   ├── ECS/           # Entity-Component-System
│   ├── Renderer/      # Graphics rendering
│   ├── Physics/       # Physics simulation
│   ├── Audio/         # Audio playback
│   ├── Scripting/     # Custom scripting language
│   └── Editor/        # Editor UI and tools
├── Shaders/           # GLSL shader files
├── Assets/            # Game assets (models, textures, sounds)
└── Game/              # Your game code</code></pre>
        </section>

        <section id="ecs-architecture">
            <h2>ECS Architecture: The Heart of the Engine</h2>

            <h3 id="ecs-philosophy">Why ECS Instead of Traditional OOP?</h3>

            <p>
                Traditional game engines often use object-oriented inheritance hierarchies. You might have classes like:
            </p>

            <pre><code class="language-cpp">class GameObject {
    Transform transform;
    virtual void Update();
};

class Enemy : public GameObject {
    Health health;
    AI ai;
};

class FlyingEnemy : public Enemy {
    FlightController flight;
};</code></pre>

            <h4>The Problems with Inheritance</h4>

            <div class="concept-box">
                <h4>1. The Diamond Problem</h4>
                <p>
                    What if you want a FlyingEnemy that can also swim? Do you create SwimmingFlyingEnemy? What about SwimmingShootingFlyingEnemy?
                    The number of classes explodes combinatorially. This is the classic multiple inheritance problem.
                </p>
                <pre><code class="language-cpp">         GameObject
            /    \
       Enemy    Swimmer
          \      /
        SwimmingEnemy  ← Which Update() do we call?</code></pre>
            </div>

            <div class="concept-box">
                <h4>2. Cache Inefficiency</h4>
                <p>
                    When you iterate over all enemies to update their AI, the data is scattered in memory:
                </p>
                <pre><code class="language-cpp">Enemy objects in memory:
[Enemy1: transform, health, ai, vtable*] [gap] [Enemy2: ...] [gap]

// Bad cache utilization: we load unnecessary data (transform, health)
// just to access ai. The vtable pointer adds overhead.</code></pre>
                <p>
                    Modern CPUs load data in cache lines (typically 64 bytes). If your Enemy object is 128 bytes but you only need
                    the AI component (16 bytes), you're wasting 87.5% of your memory bandwidth.
                </p>
            </div>

            <div class="concept-box">
                <h4>3. Rigid Structure</h4>
                <p>
                    Adding a new capability to a GameObject requires modifying the class hierarchy. Want to add particle effects to some
                    enemies? You need to either add it to the base Enemy class (bloating all enemies) or create a new subclass
                    (explosion of combinations).
                </p>
            </div>

            <h4>The ECS Solution</h4>

            <p>
                Entity-Component-System architecture solves these problems by separating <strong>identity</strong>, <strong>data</strong>,
                and <strong>behavior</strong>:
            </p>

            <ul>
                <li><strong>Entities</strong> are just IDs - lightweight identifiers for game objects</li>
                <li><strong>Components</strong> are pure data structures - no behavior, just properties</li>
                <li><strong>Systems</strong> contain behavior - they process entities with specific component combinations</li>
            </ul>

            <div class="comparison-box-vertical">
                <div class="comparison-left">
                    <h4>OOP Approach</h4>
                    <pre><code class="language-cpp">class Enemy {
    Transform transform;
    Health health;
    AI ai;

    void Update() {
        // Update AI
        // Update health
    }
};</code></pre>
                </div>
                <div class="comparison-right">
                    <h4>ECS Approach</h4>
                    <pre><code class="language-cpp">// Entity = 42 (just an ID)

// Components (data only)
Transform{pos, rot, scale}
Health{current, max}
AI{state, target}

// System (behavior)
AISystem processes entities
with [Transform, AI]</code></pre>
                </div>
            </div>

            <p>
                With ECS, creating a flying swimming shooting enemy is trivial: just add FlyingComponent, SwimmingComponent, and
                ShootingComponent to an entity. No new classes needed.
            </p>

            <h3 id="ecs-entity">Building the Entity System</h3>

            <h4>What is an Entity?</h4>

            <p>
                An entity is conceptually a game object, but in implementation, it's just a unique identifier - an unsigned integer.
                This is the first key insight of ECS: <strong>entities don't contain data or behavior</strong>.
            </p>

            <div class="concept-box">
                <h4>Design Decision: Why uint32_t?</h4>
                <p>
                    We use a 32-bit unsigned integer for Entity IDs. Why?
                </p>
                <ul>
                    <li><strong>Range</strong>: Supports up to 4.2 billion unique entities (more than enough for any game)</li>
                    <li><strong>Size</strong>: 4 bytes fits in CPU registers, fast to copy and compare</li>
                    <li><strong>Simplicity</strong>: No need for complex handle/reference systems</li>
                </ul>
                <p>
                    Some engines use versioned handles (handle = generation << 24 | index) to detect use-after-free bugs. We use a
                    simpler approach with validation checks.
                </p>
            </div>

            <h4>Entity Implementation</h4>

            <pre><code class="language-cpp">#pragma once

#include &lt;cstdint&gt;
#include &lt;limits&gt;

namespace Xi {

    // An entity is just a unique ID
    using Entity = uint32_t;

    // Special value representing an invalid/null entity
    constexpr Entity INVALID_ENTITY = std::numeric_limits&lt;Entity&gt;::max();

    // Component type identification
    using ComponentTypeID = uint32_t;

    // Generate unique type IDs for component types
    inline ComponentTypeID GetNextComponentTypeID() {
        static ComponentTypeID lastID = 0;
        return lastID++;  // Post-increment ensures uniqueness
    }

    // Template function to get a unique ID for each component type
    template&lt;typename T&gt;
    inline ComponentTypeID GetComponentTypeID() {
        // Static variable means this ID is generated once per type T
        static ComponentTypeID typeID = GetNextComponentTypeID();
        return typeID;
    }

    // Maximum number of component types in the engine
    constexpr size_t MAX_COMPONENTS = 64;
}</code></pre>

            <div class="concept-box">
                <h4>Understanding Component Type IDs</h4>
                <p>
                    The <code>GetComponentTypeID&lt;T&gt;()</code> function uses a clever C++ trick:
                </p>
                <ol>
                    <li>Each template instantiation gets its own static variable</li>
                    <li>The first call to <code>GetComponentTypeID&lt;Transform&gt;()</code> calls <code>GetNextComponentTypeID()</code> which returns 0</li>
                    <li>The first call to <code>GetComponentTypeID&lt;Health&gt;()</code> calls <code>GetNextComponentTypeID()</code> which returns 1</li>
                    <li>Subsequent calls return the cached value from the static variable</li>
                </ol>
                <p>
                    This gives us automatic, type-safe component identification without manual registration or macros.
                </p>
            </div>

            <h4>Why MAX_COMPONENTS = 64?</h4>

            <p>
                We limit the engine to 64 component types because we use a <code>std::bitset&lt;64&gt;</code> to represent which
                components an entity has. This "component mask" allows for extremely fast queries:
            </p>

            <pre><code class="language-cpp">// Check if entity has Transform and Mesh components
if (entityMask.test(transformID) && entityMask.test(meshID)) {
    // Entity has both components - single CPU instruction per check
}</code></pre>

            <p>
                64 component types is more than sufficient for most games. If you need more, you can increase this limit or use a
                dynamic bitset implementation.
            </p>

            <h3 id="ecs-component">Component Storage: Optimizing for Cache Performance</h3>

            <h4>The Memory Layout Challenge</h4>

            <p>
                Components are the data of your game. A Transform component might contain position, rotation, and scale. A Health
                component contains current and max health values. The question is: <strong>how do we store these in memory?</strong>
            </p>

            <div class="concept-box">
                <h4>Naive Approach: Per-Entity Storage</h4>
                <pre><code class="language-cpp">struct EntityData {
    Entity id;
    Transform* transform;
    Health* health;
    AI* ai;
    // ... pointers to all possible components
};</code></pre>
                <p>
                    <strong>Problems:</strong>
                </p>
                <ul>
                    <li>Wastes memory for null pointers (most entities don't have all components)</li>
                    <li>Poor cache locality - components scattered across heap allocations</li>
                    <li>Pointer indirection overhead on every access</li>
                </ul>
            </div>

            <h4>ECS Approach: Component Pools</h4>

            <p>
                Instead of storing components per-entity, we store all components of the same type together in contiguous arrays.
                This is called an "archetype" or "pool" approach:
            </p>

            <pre><code class="language-plaintext">Memory Layout:

Transform Pool:
[Entity 1 Transform][Entity 2 Transform][Entity 5 Transform][Entity 7 Transform]...

Health Pool:
[Entity 1 Health][Entity 3 Health][Entity 5 Health][Entity 9 Health]...

AI Pool:
[Entity 2 AI][Entity 5 AI][Entity 7 AI]...</code></pre>

            <div class="concept-box">
                <h4>Why This is Fast</h4>
                <p>
                    When the AI system processes all entities with AI components:
                </p>
                <pre><code class="language-cpp">for (AI& ai : aiPool) {
    ai.Update();  // All AI data is sequential in memory
}</code></pre>
                <p>
                    The CPU prefetcher sees the linear access pattern and automatically loads the next cache line before you need it.
                    This can be <strong>10-100x faster</strong> than random memory access through pointers.
                </p>
            </div>

            <h4>Component Pool Implementation</h4>

            <pre><code class="language-cpp">#pragma once

#include "Entity.h"
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;memory&gt;
#include &lt;bitset&gt;

namespace Xi {

    // Component mask: bitset where each bit represents a component type
    using ComponentMask = std::bitset&lt;MAX_COMPONENTS&gt;;

    // Abstract base class for type-erased component pools
    class ComponentPoolBase {
    public:
        virtual ~ComponentPoolBase() = default;
        virtual void RemoveEntity(Entity entity) = 0;
        virtual bool HasEntity(Entity entity) const = 0;
        virtual void Clear() = 0;
    };

    // Templated component pool for a specific component type T
    template&lt;typename T&gt;
    class ComponentPool : public ComponentPoolBase {
    public:
        // Add a component for an entity (or return existing)
        T& Add(Entity entity) {
            // Check if entity already has this component
            if (m_EntityToIndex.find(entity) != m_EntityToIndex.end()) {
                return m_Components[m_EntityToIndex[entity]];
            }

            // Add new component
            size_t index = m_Components.size();
            m_Components.emplace_back();  // Default construct component
            m_Entities.push_back(entity);
            m_EntityToIndex[entity] = index;
            return m_Components.back();
        }

        T& Get(Entity entity) {
            return m_Components[m_EntityToIndex.at(entity)];
        }

        const T& Get(Entity entity) const {
            return m_Components[m_EntityToIndex.at(entity)];
        }

        bool HasEntity(Entity entity) const override {
            return m_EntityToIndex.find(entity) != m_EntityToIndex.end();
        }

        void RemoveEntity(Entity entity) override {
            auto it = m_EntityToIndex.find(entity);
            if (it == m_EntityToIndex.end()) return;

            size_t indexToRemove = it->second;
            size_t lastIndex = m_Components.size() - 1;

            // Swap-and-pop: move last element to removed position
            if (indexToRemove != lastIndex) {
                m_Components[indexToRemove] = std::move(m_Components[lastIndex]);
                m_Entities[indexToRemove] = m_Entities[lastIndex];
                m_EntityToIndex[m_Entities[indexToRemove]] = indexToRemove;
            }

            m_Components.pop_back();
            m_Entities.pop_back();
            m_EntityToIndex.erase(entity);
        }

        void Clear() override {
            m_Components.clear();
            m_Entities.clear();
            m_EntityToIndex.clear();
        }

        // Iteration support
        std::vector&lt;T&gt;& GetComponents() { return m_Components; }
        const std::vector&lt;T&gt;& GetComponents() const { return m_Components; }
        std::vector&lt;Entity&gt;& GetEntities() { return m_Entities; }
        const std::vector&lt;Entity&gt;& GetEntities() const { return m_Entities; }

        size_t Size() const { return m_Components.size(); }

    private:
        std::vector&lt;T&gt; m_Components;           // Dense array of components
        std::vector&lt;Entity&gt; m_Entities;        // Parallel array of entity IDs
        std::unordered_map&lt;Entity, size_t&gt; m_EntityToIndex;  // Entity → index mapping
    };

}</code></pre>

            <div class="concept-box">
                <h4>Data Structure Deep Dive</h4>
                <p>
                    The ComponentPool uses three data structures working together:
                </p>
                <ol>
                    <li>
                        <strong>m_Components</strong>: Dense array of components (cache-friendly iteration)
                        <pre><code class="language-plaintext">[Transform1][Transform2][Transform3]...</code></pre>
                    </li>
                    <li>
                        <strong>m_Entities</strong>: Parallel array mapping index to entity ID
                        <pre><code class="language-plaintext">[Entity 42][Entity 7][Entity 103]...</code></pre>
                    </li>
                    <li>
                        <strong>m_EntityToIndex</strong>: Hash map for fast entity → index lookup
                        <pre><code class="language-plaintext">{42 → 0, 7 → 1, 103 → 2}</code></pre>
                    </li>
                </ol>
                <p>
                    This hybrid approach gives us O(1) access by entity ID and cache-friendly sequential iteration.
                </p>
            </div>

            <h4>The Swap-and-Pop Technique</h4>

            <p>
                When removing a component, we use "swap-and-pop" to maintain a dense array without holes:
            </p>

            <pre><code class="language-plaintext">// Before removing entity 7:
Components: [Transform1][Transform2][Transform3][Transform4]
Entities:   [42]        [7]         [103]       [256]
Index map:  {42→0, 7→1, 103→2, 256→3}

// After swap-and-pop:
Components: [Transform1][Transform4][Transform3]
Entities:   [42]        [256]       [103]
Index map:  {42→0, 256→1, 103→2}</code></pre>

            <p>
                We swap the removed element with the last element, then pop the last element. This keeps the array dense
                (no holes) while being O(1). The tradeoff is that iteration order is not stable - but in ECS, we don't care
                about entity order, only about processing all entities efficiently.
            </p>

            <h3 id="ecs-world">World Manager: Orchestrating Entities and Components</h3>

            <h4>The World's Responsibility</h4>

            <p>
                The World class is the central hub of the ECS system. It manages:
            </p>

            <ul>
                <li>Entity creation and destruction</li>
                <li>Component pools (one per component type)</li>
                <li>Entity metadata (name, active state, parent-child hierarchy)</li>
                <li>Systems (update logic that processes components)</li>
            </ul>

            <div class="concept-box">
                <h4>Design Decision: Single World vs Multiple Worlds</h4>
                <p>
                    Some engines support multiple "worlds" for implementing different game states or streaming levels. We use a
                    single world for simplicity, but the architecture could be extended to support multiple worlds by making
                    World a copyable/movable object.
                </p>
            </div>

            <h4>World Implementation</h4>

            <pre><code class="language-cpp">#pragma once

#include "Entity.h"
#include "Component.h"
#include "System.h"
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;functional&gt;

namespace Xi {

    // Entity metadata (not a component - always present)
    struct EntityInfo {
        std::string name;
        bool active = true;
        Entity parent = INVALID_ENTITY;
        std::vector&lt;Entity&gt; children;
    };

    class World {
    public:
        World();
        ~World();

        // Entity management
        Entity CreateEntity(const std::string& name = "Entity");
        void DestroyEntity(Entity entity);
        bool IsEntityValid(Entity entity) const;

        // Entity properties
        const std::string& GetEntityName(Entity entity) const;
        void SetEntityName(Entity entity, const std::string& name);
        bool IsEntityActive(Entity entity) const;
        void SetEntityActive(Entity entity, bool active);

        // Hierarchy management
        void SetParent(Entity child, Entity parent);
        Entity GetParent(Entity entity) const;
        const std::vector&lt;Entity&gt;& GetChildren(Entity entity) const;

        // Component management (templated for type safety)
        template&lt;typename T&gt;
        T& AddComponent(Entity entity) {
            ComponentTypeID typeID = GetComponentTypeID&lt;T&gt;();
            EnsureComponentPool&lt;T&gt;(typeID);

            auto* pool = static_cast&lt;ComponentPool&lt;T&gt;*&gt;(m_ComponentPools[typeID].get());
            T& component = pool-&gt;Add(entity);

            // Set the bit for this component type
            m_EntityMasks[entity].set(typeID);
            return component;
        }

        template&lt;typename T&gt;
        void RemoveComponent(Entity entity) {
            ComponentTypeID typeID = GetComponentTypeID&lt;T&gt;();
            if (typeID &gt;= m_ComponentPools.size() || !m_ComponentPools[typeID]) return;

            auto* pool = static_cast&lt;ComponentPool&lt;T&gt;*&gt;(m_ComponentPools[typeID].get());
            pool-&gt;RemoveEntity(entity);
            m_EntityMasks[entity].reset(typeID);
        }

        template&lt;typename T&gt;
        T& GetComponent(Entity entity) {
            ComponentTypeID typeID = GetComponentTypeID&lt;T&gt;();
            auto* pool = static_cast&lt;ComponentPool&lt;T&gt;*&gt;(m_ComponentPools[typeID].get());
            return pool-&gt;Get(entity);
        }

        template&lt;typename T&gt;
        bool HasComponent(Entity entity) const {
            ComponentTypeID typeID = GetComponentTypeID&lt;T&gt;();
            if (typeID &gt;= m_ComponentPools.size() || !m_ComponentPools[typeID])
                return false;

            auto it = m_EntityMasks.find(entity);
            if (it == m_EntityMasks.end()) return false;

            return it-&gt;second.test(typeID);
        }

        // Iterate entities with specific component types
        template&lt;typename... Components&gt;
        void ForEach(std::function&lt;void(Entity, Components&...)&gt; func) {
            // Get the first component pool to iterate over
            using FirstComponent = std::tuple_element_t&lt;0, std::tuple&lt;Components...&gt;&gt;;
            auto* pool = GetComponentPool&lt;FirstComponent&gt;();
            if (!pool) return;

            // Iterate all entities in the first pool
            for (Entity entity : pool-&gt;GetEntities()) {
                // Check if entity has all required components
                if ((HasComponent&lt;Components&gt;(entity) && ...)) {
                    // Call the function with the entity and all its components
                    func(entity, GetComponent&lt;Components&gt;(entity)...);
                }
            }
        }

        // System management
        void Update(float dt);
        void Render(Renderer& renderer);

    private:
        template&lt;typename T&gt;
        void EnsureComponentPool(ComponentTypeID typeID) {
            if (typeID &gt;= m_ComponentPools.size()) {
                m_ComponentPools.resize(typeID + 1);
            }
            if (!m_ComponentPools[typeID]) {
                m_ComponentPools[typeID] = std::make_unique&lt;ComponentPool&lt;T&gt;&gt;();
            }
        }

        template&lt;typename T&gt;
        ComponentPool&lt;T&gt;* GetComponentPool() {
            ComponentTypeID typeID = GetComponentTypeID&lt;T&gt;();
            if (typeID &gt;= m_ComponentPools.size() || !m_ComponentPools[typeID])
                return nullptr;
            return static_cast&lt;ComponentPool&lt;T&gt;*&gt;(m_ComponentPools[typeID].get());
        }

        Entity m_NextEntityID = 0;
        std::unordered_map&lt;Entity, EntityInfo&gt; m_EntityInfo;
        std::unordered_map&lt;Entity, ComponentMask&gt; m_EntityMasks;
        std::vector&lt;std::unique_ptr&lt;ComponentPoolBase&gt;&gt; m_ComponentPools;
        std::vector&lt;std::unique_ptr&lt;System&gt;&gt; m_Systems;
    };

}</code></pre>

            <div class="concept-box">
                <h4>Understanding ForEach: Variadic Template Magic</h4>
                <p>
                    The <code>ForEach</code> function is a powerful query mechanism using C++17 features:
                </p>
                <pre><code class="language-plaintext">// Usage example:
world.ForEach&lt;Transform, Velocity&gt;([](Entity e, Transform& t, Velocity& v) {
    t.position += v.velocity * deltaTime;
});</code></pre>
                <p>
                    Let's break down how it works:
                </p>
                <ol>
                    <li><code>template&lt;typename... Components&gt;</code> - Accepts any number of component types</li>
                    <li><code>std::tuple_element_t&lt;0, ...&gt;</code> - Extracts the first component type</li>
                    <li><code>(HasComponent&lt;Components&gt;(entity) && ...)</code> - Fold expression: checks if entity has ALL components</li>
                    <li><code>GetComponent&lt;Components&gt;(entity)...</code> - Parameter pack expansion: gets all components</li>
                </ol>
                <p>
                    This gives us a type-safe, compile-time checked query system with zero runtime overhead.
                </p>
            </div>

            <h4>Component Masks for Fast Queries</h4>

            <p>
                Each entity has a ComponentMask (bitset) where each bit represents whether the entity has that component:
            </p>

            <pre><code class="language-plaintext">Entity 42 Mask: 00000000 00000000 00000000 00000111
                                                    |||
                                                    ||+- Bit 0: Transform
                                                    |+-- Bit 1: MeshRenderer
                                                    +--- Bit 2: RigidBody

// Checking if entity has Transform and RigidBody:
requiredMask = 00000000 00000000 00000000 00000101
entityMask   = 00000000 00000000 00000000 00000111
AND result   = 00000000 00000000 00000000 00000101  ← Matches! Has both.</code></pre>

            <p>
                This bit-testing is extremely fast (single CPU instruction) compared to multiple hash map lookups.
            </p>

            <h3 id="ecs-systems">System Framework: Processing Components</h3>

            <h4>What is a System?</h4>

            <p>
                In ECS, systems are where the behavior lives. A system:
            </p>

            <ul>
                <li>Queries entities with specific component combinations</li>
                <li>Processes those components (reads and writes data)</li>
                <li>Runs during Update or Render phase</li>
            </ul>

            <div class="concept-box">
                <h4>Example: Transform System</h4>
                <p>
                    A TransformSystem updates world matrices based on local transforms and parent-child relationships:
                </p>
                <pre><code class="language-cpp">class TransformSystem : public System {
public:
    void Update(World& world, float dt) override {
        // Process root entities first
        for (Entity root : world.GetRootEntities()) {
            UpdateTransformHierarchy(world, root, glm::mat4(1.0f));
        }
    }

private:
    void UpdateTransformHierarchy(World& world, Entity entity, const glm::mat4& parentMatrix) {
        if (!world.HasComponent&lt;Transform&gt;(entity)) return;

        Transform& t = world.GetComponent&lt;Transform&gt;(entity);
        t.worldMatrix = parentMatrix * t.GetLocalMatrix();

        // Recursively update children
        for (Entity child : world.GetChildren(entity)) {
            UpdateTransformHierarchy(world, child, t.worldMatrix);
        }
    }
};</code></pre>
                <p>
                    Notice how the system doesn't store data - it just processes components. This separation makes systems
                    easy to add, remove, and reorder.
                </p>
            </div>

            <h4>System Execution Order</h4>

            <p>
                Systems must run in a specific order to maintain data dependencies:
            </p>

            <pre><code class="language-plaintext">Update Phase:
1. ScriptSystem         → Executes game scripts
2. TransformSystem      → Updates world matrices
3. PhysicsSystem        → Simulates physics
4. AnimationSystem      → Updates skeletal animations

Render Phase:
1. CameraSystem         → Updates camera matrices
2. LightingSystem       → Culls and sorts lights
3. RenderSystem         → Submits draw calls</code></pre>

            <p>
                The World class maintains a vector of systems and calls them in registration order. For more complex dependencies,
                you could implement a dependency graph and topological sort.
            </p>

            <h4>Data Flow Diagram</h4>

            <pre><code class="language-plaintext">                     ┌─────────────┐
                     │   World     │
                     │  (Entity    │
                     │   Manager)  │
                     └──────┬──────┘
                            │
            ┌───────────────┼───────────────┐
            │               │               │
    ┌───────▼──────┐ ┌──────▼──────┐ ┌─────▼──────┐
    │  Transform   │ │   Physics   │ │   Render   │
    │    Pool      │ │    Pool     │ │    Pool    │
    └───────┬──────┘ └──────┬──────┘ └─────┬──────┘
            │               │               │
    ┌───────▼──────┐ ┌──────▼──────┐ ┌─────▼──────┐
    │  Transform   │ │   Physics   │ │   Render   │
    │   System     │ │   System    │ │   System   │
    └──────────────┘ └─────────────┘ └────────────┘

Data flows: Pool → System (read) → Pool (write)</code></pre>

            <p>
                Systems read component data, perform computations, and write results back to components. The World orchestrates
                this data flow each frame.
            </p>
        </section>

        <section id="scripting-engine">
            <h2>Scripting Engine: Empowering Game Designers</h2>

            <h3 id="script-why">Custom Scripting vs Embedded Languages</h3>

            <h4>Why Add Scripting to a Game Engine?</h4>

            <p>
                Scripting languages enable non-programmers to create game logic without recompiling C++ code. Benefits include:
            </p>

            <ul>
                <li><strong>Rapid iteration</strong>: Modify scripts and see changes immediately</li>
                <li><strong>Safety</strong>: Scripts can't crash the engine (with proper sandboxing)</li>
                <li><strong>Accessibility</strong>: Designers and artists can contribute to gameplay</li>
                <li><strong>Hot reloading</strong>: Update scripts while the game is running</li>
            </ul>

            <h4>Embedded vs Custom Language</h4>

            <div class="comparison-box-vertical">
                <div class="comparison-left">
                    <h4>Embedded (Lua/Python)</h4>
                    <p><strong>Pros:</strong></p>
                    <ul>
                        <li>Mature, well-tested implementations</li>
                        <li>Rich ecosystem of libraries</li>
                        <li>Familiar syntax for many developers</li>
                        <li>Excellent performance (LuaJIT)</li>
                    </ul>
                    <p><strong>Cons:</strong></p>
                    <ul>
                        <li>Integration overhead (C API bindings)</li>
                        <li>Memory management mismatches</li>
                        <li>Larger binary size</li>
                        <li>Language features you don't need</li>
                    </ul>
                </div>
                <div class="comparison-right">
                    <h4>Custom Language</h4>
                    <p><strong>Pros:</strong></p>
                    <ul>
                        <li>Tailored to your engine's needs</li>
                        <li>Simple, predictable behavior</li>
                        <li>No external dependencies</li>
                        <li>Full control over features</li>
                    </ul>
                    <p><strong>Cons:</strong></p>
                    <ul>
                        <li>Implementation time and effort</li>
                        <li>Limited standard library</li>
                        <li>Potential bugs and edge cases</li>
                        <li>Slower performance (without JIT)</li>
                    </ul>
                </div>
            </div>

            <div class="concept-box">
                <h4>Our Decision: Custom Lua-Like Language</h4>
                <p>
                    We implement a custom scripting language inspired by Lua for educational purposes. In production, you'd likely
                    use LuaJIT or AngelScript. Building a custom interpreter teaches you:
                </p>
                <ul>
                    <li>How programming languages work internally</li>
                    <li>Lexical analysis and parsing techniques</li>
                    <li>Runtime type systems and memory management</li>
                    <li>Bridging C++ and scripted code</li>
                </ul>
            </div>

            <h3 id="script-compiler">Compiler Theory Basics</h3>

            <h4>The Compilation Pipeline</h4>

            <p>
                Turning source code into executable instructions involves several stages:
            </p>

            <pre><code class="language-plaintext">Source Code → Lexer → Tokens → Parser → AST → Interpreter → Execution

"x = 5 + 3"     [ID][=][NUM][+][NUM]    AssignStmt     Evaluate and
                                        /    \          execute
                                     Var: x  BinaryExpr
                                             /    \
                                           5       3</code></pre>

            <div class="concept-box">
                <h4>Stage 1: Lexical Analysis (Lexing)</h4>
                <p>
                    The lexer breaks source code into tokens - the smallest meaningful units:
                </p>
                <pre><code class="language-lua">Input:  "local health = 100"

Output: [
    Token{type: LOCAL,      value: "local"},
    Token{type: IDENTIFIER, value: "health"},
    Token{type: EQUALS,     value: "="},
    Token{type: NUMBER,     value: "100"}
]</code></pre>
                <p>
                    The lexer handles:
                </p>
                <ul>
                    <li>Whitespace and comment removal</li>
                    <li>Keyword recognition (if, while, function, etc.)</li>
                    <li>String literal parsing (handling escape sequences)</li>
                    <li>Number parsing (integers, floats, scientific notation)</li>
                    <li>Operator recognition (+, -, *, /, ==, !=, etc.)</li>
                </ul>
            </div>

            <div class="concept-box">
                <h4>Stage 2: Parsing</h4>
                <p>
                    The parser builds an Abstract Syntax Tree (AST) from tokens using grammar rules:
                </p>
                <pre><code class="language-plaintext">Grammar Rules:
statement    → "local" IDENTIFIER "=" expression
expression   → term (("+"|"-") term)*
term         → factor (("*"|"/") factor)*
factor       → NUMBER | IDENTIFIER | "(" expression ")"

Parsing "local health = 100 + 50":

        LocalStmt
        /       \
    "health"   BinaryExpr(+)
                /      \
              100      50</code></pre>
                <p>
                    The parser ensures syntax is correct and creates a tree structure representing the program's logic.
                </p>
            </div>

            <div class="concept-box">
                <h4>Stage 3: Interpretation</h4>
                <p>
                    The interpreter walks the AST and executes nodes:
                </p>
                <pre><code class="language-plaintext">Execute(LocalStmt):
    1. Evaluate right-hand expression (100 + 50)
    2. Create variable "health" in current scope
    3. Store value 150

Execute(BinaryExpr +):
    1. Evaluate left child → 100
    2. Evaluate right child → 50
    3. Perform addition → 150
    4. Return result</code></pre>
                <p>
                    This is a tree-walking interpreter - simple but slower than bytecode or JIT compilation. For a game engine,
                    it's fast enough for gameplay scripts (not performance-critical inner loops).
                </p>
            </div>

            <h3 id="script-values">Value System: Runtime Type Management</h3>

            <h4>Dynamic Typing Challenge</h4>

            <p>
                Scripting languages are typically dynamically typed - variables can hold any type at runtime. In C++, we need to
                represent this flexibility while maintaining type safety.
            </p>

            <div class="concept-box">
                <h4>Approach 1: std::variant (Modern C++)</h4>
                <pre><code class="language-cpp">using ScriptValue = std::variant&lt;
    std::monostate,      // Nil
    bool,                // Boolean
    double,              // Number
    std::string,         // String
    glm::vec3,           // Vector3
    std::unordered_map   // Table
&gt;;</code></pre>
                <p>
                    <strong>Pros:</strong> Type-safe, no manual memory management, modern C++
                </p>
                <p>
                    <strong>Cons:</strong> Overhead from std::visit, can't store custom types easily
                </p>
            </div>

            <div class="concept-box">
                <h4>Approach 2: Tagged Union (Our Approach)</h4>
                <pre><code class="language-cpp">class ScriptValue {
    enum class Type { Nil, Bool, Number, String, Vec3, Table, Function };

    Type m_Type;
    union {
        bool m_Bool;
        double m_Number;
        // Non-trivial types as member variables
    };
};</code></pre>
                <p>
                    <strong>Pros:</strong> Explicit control, easy to extend, clear semantics
                </p>
                <p>
                    <strong>Cons:</strong> Manual memory management for non-trivial types
                </p>
            </div>

            <h4>ScriptValue Implementation</h4>

            <pre><code class="language-cpp">#pragma once

#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;functional&gt;
#include &lt;glm/glm.hpp&gt;

namespace Xi {

    class ScriptValue;
    using ScriptFunction = std::function&lt;ScriptValue(const std::vector&lt;ScriptValue&gt;&)&gt;;

    class ScriptValue {
    public:
        enum class Type {
            Nil,             // Represents absence of value
            Bool,            // True/false
            Number,          // Double-precision float
            String,          // UTF-8 string
            Vec3,            // 3D vector (game-specific type)
            Table,           // Hash map (like Lua tables)
            Function,        // Script-defined function
            NativeFunction,  // C++ function callable from script
            UserData         // Opaque pointer to C++ object
        };

        // Constructors for each type
        ScriptValue() : m_Type(Type::Nil) {}
        ScriptValue(bool b) : m_Type(Type::Bool), m_Bool(b) {}
        ScriptValue(double n) : m_Type(Type::Number), m_Number(n) {}
        ScriptValue(const std::string& s) : m_Type(Type::String), m_String(s) {}
        ScriptValue(const glm::vec3& v) : m_Type(Type::Vec3), m_Vec3(v) {}
        ScriptValue(ScriptFunction func) : m_Type(Type::NativeFunction), m_NativeFunc(func) {}
        ScriptValue(void* ptr) : m_Type(Type::UserData), m_UserData(ptr) {}

        // Type checking
        Type GetType() const { return m_Type; }
        bool IsNil() const { return m_Type == Type::Nil; }
        bool IsNumber() const { return m_Type == Type::Number; }
        bool IsString() const { return m_Type == Type::String; }

        // Value extraction (with type checking in implementation)
        double AsNumber() const { return m_Number; }
        const std::string& AsString() const { return m_String; }
        const glm::vec3& AsVec3() const { return m_Vec3; }

        // Table operations (like Lua tables - can hold any value)
        void SetTable(const std::string& key, const ScriptValue& value);
        ScriptValue GetTable(const std::string& key) const;

        // Arithmetic operators
        ScriptValue operator+(const ScriptValue& other) const;
        ScriptValue operator-(const ScriptValue& other) const;
        ScriptValue operator*(const ScriptValue& other) const;
        ScriptValue operator/(const ScriptValue& other) const;

        // Comparison operators
        bool operator==(const ScriptValue& other) const;
        bool operator&lt;(const ScriptValue& other) const;

        std::string ToString() const;

    private:
        Type m_Type = Type::Nil;

        // Storage for different types
        bool m_Bool = false;
        double m_Number = 0.0;
        std::string m_String;
        glm::vec3 m_Vec3 = glm::vec3(0.0f);
        std::unordered_map&lt;std::string, ScriptValue&gt; m_Table;
        ScriptFunction m_NativeFunc;
        void* m_UserData = nullptr;
        int m_FuncIndex = -1;  // Index into interpreter's function table
    };

}</code></pre>

            <div class="concept-box">
                <h4>Understanding Tables</h4>
                <p>
                    Tables are the most powerful data structure in our scripting language (inspired by Lua). A table is a hash map
                    that can store any type:
                </p>
                <pre><code class="language-plaintext">-- Script code:
local player = {
    name = "Hero",
    health = 100,
    position = Vec3(0, 0, 0),
    inventory = {
        gold = 50,
        items = {}
    }
}

-- Internally stored as:
Table {
    "name" → String("Hero"),
    "health" → Number(100),
    "position" → Vec3(0, 0, 0),
    "inventory" → Table { ... }
}</code></pre>
                <p>
                    Tables can represent objects, arrays, dictionaries, and even classes (through metatables, not shown here).
                </p>
            </div>

            <h4>Operator Overloading for Natural Syntax</h4>

            <p>
                We overload C++ operators to make script value manipulation feel natural:
            </p>

            <pre><code class="language-cpp">ScriptValue ScriptValue::operator+(const ScriptValue& other) const {
    // Number + Number
    if (IsNumber() && other.IsNumber()) {
        return ScriptValue(m_Number + other.m_Number);
    }

    // String + String (concatenation)
    if (IsString() && other.IsString()) {
        return ScriptValue(m_String + other.m_String);
    }

    // Vec3 + Vec3 (vector addition)
    if (IsVec3() && other.IsVec3()) {
        return ScriptValue(m_Vec3 + other.m_Vec3);
    }

    // Type error
    throw std::runtime_error("Cannot add " + ToString() + " and " + other.ToString());
}</code></pre>

            <p>
                This allows the interpreter to evaluate expressions like <code>health + 10</code> or <code>position + velocity</code>
                with natural C++ syntax.
            </p>

            <h3 id="script-interpreter">Interpreter Design: Executing Scripts</h3>

            <h4>Environment and Scope Management</h4>

            <p>
                The interpreter maintains a scope chain to resolve variable names:
            </p>

            <pre><code class="language-cpp">Global Scope: { print = [NativeFunc], Vec3 = [NativeFunc] }
    |
    +-- Function Scope: { x = 10, y = 20 }
            |
            +-- Block Scope (if statement): { temp = 5 }</code></pre>

            <div class="concept-box">
                <h4>Scope Resolution Algorithm</h4>
                <pre><code class="language-plaintext">function GetVariable(name):
    current = currentScope
    while current != null:
        if current.variables.contains(name):
            return current.variables[name]
        current = current.parent

    // Not found in any scope
    throw "Undefined variable: " + name</code></pre>
                <p>
                    This implements lexical scoping - inner scopes can access outer scope variables, but not vice versa.
                </p>
            </div>

            <h4>Interpreter Implementation</h4>

            <pre><code class="language-cpp">#pragma once

#include "ScriptValue.h"
#include "ScriptAST.h"  // AST node definitions
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

namespace Xi {

    class ScriptInterpreter {
    public:
        ScriptInterpreter();

        // Execute a list of statements
        void Execute(const std::vector&lt;StmtNodePtr&gt;& statements);

        // Global environment access (for exposing engine functions)
        void SetGlobal(const std::string& name, const ScriptValue& value);
        ScriptValue GetGlobal(const std::string& name) const;

        // Call a script function from C++
        ScriptValue CallFunction(const std::string& name,
                                 const std::vector&lt;ScriptValue&gt;& args = {});

        // Error handling
        bool HasError() const { return !m_Error.empty(); }
        const std::string& GetError() const { return m_Error; }

    private:
        // Scope management
        struct Environment {
            std::unordered_map&lt;std::string, ScriptValue&gt; variables;
            Environment* parent = nullptr;
        };

        void PushScope();  // Enter new scope (function call, block)
        void PopScope();   // Exit scope
        void SetVariable(const std::string& name, const ScriptValue& value);
        ScriptValue GetVariable(const std::string& name) const;

        // Statement execution (recursive)
        void ExecuteStmt(const StmtNodePtr& stmt);
        void ExecuteLocal(const LocalStmt* stmt);
        void ExecuteAssign(const AssignStmt* stmt);
        void ExecuteIf(const IfStmt* stmt);
        void ExecuteWhile(const WhileStmt* stmt);
        void ExecuteFunction(const FunctionStmt* stmt);
        void ExecuteReturn(const ReturnStmt* stmt);

        // Expression evaluation (recursive)
        ScriptValue Evaluate(const ExprNodePtr& expr);
        ScriptValue EvalNumber(const NumberExpr* expr);
        ScriptValue EvalString(const StringExpr* expr);
        ScriptValue EvalIdentifier(const IdentifierExpr* expr);
        ScriptValue EvalBinary(const BinaryExpr* expr);
        ScriptValue EvalUnary(const UnaryExpr* expr);
        ScriptValue EvalCall(const CallExpr* expr);
        ScriptValue EvalMember(const MemberExpr* expr);  // table.field
        ScriptValue EvalIndex(const IndexExpr* expr);    // table[key]

        Environment m_GlobalEnv;     // Top-level scope
        Environment* m_CurrentEnv;   // Current active scope

        // Function storage
        struct StoredFunction {
            std::vector&lt;std::string&gt; params;
            std::vector&lt;StmtNodePtr&gt; body;
        };
        std::vector&lt;StoredFunction&gt; m_Functions;

        // Control flow state
        bool m_Returning = false;
        std::vector&lt;ScriptValue&gt; m_ReturnValues;

        std::string m_Error;
    };

}</code></pre>

            <div class="concept-box">
                <h4>Recursive Evaluation Example</h4>
                <p>
                    Let's trace how the interpreter evaluates <code>2 + 3 * 4</code>:
                </p>
                <pre><code class="language-plaintext">Evaluate(BinaryExpr +):
    left = Evaluate(NumberExpr 2) → 2
    right = Evaluate(BinaryExpr *):
        left = Evaluate(NumberExpr 3) → 3
        right = Evaluate(NumberExpr 4) → 4
        return 3 * 4 → 12
    return 2 + 12 → 14

Tree structure:
        +
       / \
      2   *
         / \
        3   4

Evaluation is post-order: evaluate children before parent.</code></pre>
            </div>

            <h4>Calling C++ Functions from Scripts</h4>

            <p>
                The bridge between C++ and scripts is the NativeFunction type:
            </p>

            <pre><code class="language-cpp">// In C++ (engine initialization):
interpreter.SetGlobal("print", ScriptValue([](const std::vector&lt;ScriptValue&gt;& args) {
    for (const auto& arg : args) {
        std::cout &lt;&lt; arg.ToString() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return ScriptValue();  // Return nil
}));

interpreter.SetGlobal("Vec3", ScriptValue([](const std::vector&lt;ScriptValue&gt;& args) {
    if (args.size() != 3) throw std::runtime_error("Vec3 requires 3 arguments");
    return ScriptValue(glm::vec3(
        args[0].AsNumber(),
        args[1].AsNumber(),
        args[2].AsNumber()
    ));
}));

// In script:
print("Hello from script!")
local pos = Vec3(1.0, 2.0, 3.0)</code></pre>

            <p>
                This pattern allows scripts to access engine functionality without knowing C++ implementation details.
            </p>

            <h4>Memory Management and Garbage Collection</h4>

            <p>
                Our interpreter uses C++ RAII for automatic memory management:
            </p>

            <ul>
                <li><strong>ScriptValue</strong> owns its data (std::string, std::unordered_map)</li>
                <li><strong>Scope exit</strong> automatically destroys local variables</li>
                <li><strong>No manual delete</strong> needed - destructors handle cleanup</li>
            </ul>

            <p>
                For a production scripting language, you'd implement a garbage collector (mark-and-sweep or reference counting)
                to handle circular references in tables. Our simple implementation doesn't support circular references.
            </p>
        </section>

        <section id="renderer">
            <h2>Rendering System: Bringing the World to Life</h2>

            <h3 id="render-pipeline">The Graphics Pipeline</h3>

            <h4>What is the Graphics Pipeline?</h4>

            <p>
                The graphics pipeline is the sequence of operations that transforms 3D vertices into pixels on the screen.
                Understanding this pipeline is crucial for optimizing rendering performance.
            </p>

            <pre><code class="language-plaintext">Vertex Data → Vertex Shader → Primitive Assembly → Rasterization → Fragment Shader → Frame Buffer

3D positions  Transform to   Connect vertices  Determine which   Calculate pixel   Write to
in model      screen space   into triangles    pixels covered    colors            screen
space</code></pre>

            <div class="concept-box">
                <h4>Pipeline Stages Explained</h4>
                <ol>
                    <li>
                        <strong>Vertex Shader</strong>: Runs once per vertex. Transforms positions from local space to clip space.
                        <pre><code class="language-glsl">// Example transformation:
gl_Position = projection * view * model * vec4(inPosition, 1.0);</code></pre>
                    </li>
                    <li>
                        <strong>Primitive Assembly</strong>: Groups vertices into triangles based on the draw mode (GL_TRIANGLES, etc.)
                    </li>
                    <li>
                        <strong>Rasterization</strong>: Determines which pixels (fragments) are covered by each triangle. Interpolates
                        vertex attributes (position, normal, UV) across the triangle surface.
                    </li>
                    <li>
                        <strong>Fragment Shader</strong>: Runs once per pixel. Calculates the final color using lighting, textures, etc.
                    </li>
                    <li>
                        <strong>Depth Testing & Blending</strong>: Determines if the fragment is visible (depth test) and how it blends
                        with existing pixels (alpha blending).
                    </li>
                </ol>
            </div>

            <h4>Coordinate Space Transformations</h4>

            <p>
                Rendering requires transforming vertices through multiple coordinate spaces:
            </p>

            <pre><code class="language-plaintext">Local Space (Model) → World Space → View Space (Camera) → Clip Space → Screen Space

         Model                View              Projection
        Matrix              Matrix               Matrix

[Mesh vertices] → [World positions] → [Relative to camera] → [Normalized -1 to 1] → [Pixel coords]</code></pre>

            <div class="concept-box">
                <h4>Why Multiple Spaces?</h4>
                <ul>
                    <li><strong>Local Space</strong>: Artist-friendly coordinates (origin at mesh center)</li>
                    <li><strong>World Space</strong>: Unified coordinate system for all objects (physics, lighting)</li>
                    <li><strong>View Space</strong>: Simplifies lighting calculations (camera at origin)</li>
                    <li><strong>Clip Space</strong>: GPU-friendly normalized coordinates for clipping and perspective divide</li>
                </ul>
            </div>

            <h3 id="render-pbr">Physically-Based Rendering (PBR)</h3>

            <h4>Why PBR Instead of Traditional Lighting?</h4>

            <p>
                Traditional lighting models (Phong, Blinn-Phong) are empirical - they look good but don't model real physics.
                PBR is based on actual light behavior, giving more realistic and consistent results across different lighting
                conditions.
            </p>

            <div class="comparison-box-vertical">
                <div class="comparison-left">
                    <h4>Phong Shading</h4>
                    <pre><code class="language-cpp">color = ambient +
        diffuse * (N · L) +
        specular * (R · V)^shininess

Problems:
- Shininess is non-physical
- Energy not conserved
- Unrealistic highlights
- Hard to make materials
  look consistent</code></pre>
                </div>
                <div class="comparison-right">
                    <h4>PBR (Cook-Torrance)</h4>
                    <pre><code class="language-cpp">color = kD * diffuse +
        kS * specular

where:
kD = diffuse weight
kS = specular weight
kD + kS ≤ 1 (energy conservation)

Uses:
- Roughness (0-1)
- Metallic (0-1)
- Physical BRDF equations</code></pre>
                </div>
            </div>

            <h4>Understanding BRDFs</h4>

            <div class="concept-box">
                <h4>What is a BRDF?</h4>
                <p>
                    BRDF stands for Bidirectional Reflectance Distribution Function. It describes how light reflects off a surface
                    based on incoming direction (L) and outgoing direction (V).
                </p>
                <pre><code class="language-plaintext">BRDF(L, V, N) → RGB color

Inputs:
- L: Light direction
- V: View direction
- N: Surface normal
- Surface properties (roughness, metallic)

Output:
- How much light reflects toward the viewer</code></pre>
                <p>
                    A mirror has a sharp BRDF (light only reflects in one direction). Rough surfaces have a broad BRDF (light
                    scatters in many directions).
                </p>
            </div>

            <h4>Cook-Torrance BRDF Implementation</h4>

            <p>
                The Cook-Torrance model splits reflection into diffuse (scattered) and specular (mirror-like) components:
            </p>

            <pre><code class="language-plaintext">f_cook-torrance = kD * f_lambert + kS * f_cook-torrance-specular

Diffuse (Lambert):
f_lambert = albedo / π

Specular:
f_specular = (D * G * F) / (4 * (N·V) * (N·L))

where:
D = Normal Distribution Function (microfacet orientation)
G = Geometry Function (self-shadowing)
F = Fresnel (reflection at different angles)</code></pre>

            <h4>Shader Implementation</h4>

            <p>
                Here's the actual fragment shader implementing Cook-Torrance PBR:
            </p>

            <pre><code class="language-glsl">#version 450 core

in vec3 v_WorldPos;
in vec3 v_Normal;
in vec2 v_TexCoord;

out vec4 FragColor;

uniform vec3 u_CameraPos;
uniform vec4 u_AlbedoColor;
uniform float u_Metallic;
uniform float u_Roughness;
uniform float u_AO;  // Ambient occlusion

// Light data
uniform int u_NumLights;
uniform vec3 u_LightPositions[8];
uniform vec3 u_LightColors[8];
uniform float u_LightIntensities[8];

const float PI = 3.14159265359;

// Fresnel-Schlick approximation
vec3 FresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

// GGX/Trowbridge-Reitz normal distribution
float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return num / denom;
}

// Schlick-GGX geometry function
float GeometrySchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;

    float num = NdotV;
    float denom = NdotV * (1.0 - k) + k;

    return num / denom;
}

// Smith's method for geometry obstruction
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

void main() {
    vec4 albedo = u_AlbedoColor;
    vec3 N = normalize(v_Normal);
    vec3 V = normalize(u_CameraPos - v_WorldPos);

    // Calculate base reflectivity (F0)
    // Non-metals: F0 = 0.04, Metals: F0 = albedo
    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo.rgb, u_Metallic);

    // Accumulate lighting from all lights
    vec3 Lo = vec3(0.0);

    for (int i = 0; i < u_NumLights && i < 8; i++) {
        // Light direction and attenuation
        vec3 L = normalize(u_LightPositions[i] - v_WorldPos);
        float distance = length(u_LightPositions[i] - v_WorldPos);
        float attenuation = 1.0 / (distance * distance);  // Inverse square law
        vec3 radiance = u_LightColors[i] * u_LightIntensities[i] * attenuation;

        // Half vector
        vec3 H = normalize(V + L);

        // Cook-Torrance BRDF
        float NDF = DistributionGGX(N, H, u_Roughness);
        float G = GeometrySmith(N, V, L, u_Roughness);
        vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);

        vec3 numerator = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
        vec3 specular = numerator / denominator;

        // Energy conservation: kS + kD = 1
        vec3 kS = F;  // Fresnel is the specular weight
        vec3 kD = vec3(1.0) - kS;
        kD *= 1.0 - u_Metallic;  // Metals have no diffuse

        float NdotL = max(dot(N, L), 0.0);
        Lo += (kD * albedo.rgb / PI + specular) * radiance * NdotL;
    }

    // Ambient lighting (simplified)
    vec3 ambient = vec3(0.03) * albedo.rgb * u_AO;
    vec3 color = ambient + Lo;

    // HDR tonemapping (Reinhard)
    color = color / (color + vec3(1.0));

    // Gamma correction
    color = pow(color, vec3(1.0 / 2.2));

    FragColor = vec4(color, albedo.a);
}</code></pre>

            <div class="concept-box">
                <h4>Understanding the Math</h4>
                <p>
                    <strong>Normal Distribution Function (GGX):</strong> Models microfacet orientation. Rough surfaces have
                    randomly oriented microfacets (wide distribution), smooth surfaces have aligned microfacets (narrow distribution).
                </p>
                <p>
                    <strong>Geometry Function (Smith):</strong> Accounts for microfacet self-shadowing. Light can be blocked by
                    adjacent microfacets before reaching the viewer.
                </p>
                <p>
                    <strong>Fresnel (Schlick):</strong> Describes how reflectivity changes with viewing angle. Looking at water
                    straight down, you see through it. At grazing angles, it's mirror-like.
                </p>
            </div>

            <h4>Why HDR and Tonemapping?</h4>

            <p>
                PBR calculations can produce values outside the 0-1 range (High Dynamic Range). We need to map these to displayable
                0-1 values without losing detail:
            </p>

            <pre><code class="language-glsl">// Without tonemapping: bright areas clip to white
color = min(color, 1.0);  // Loses all detail above 1.0

// With Reinhard tonemapping: smoothly compresses bright areas
color = color / (color + 1.0);  // Asymptotically approaches 1.0

Example:
Input:  [2.0, 5.0, 10.0]
Output: [0.67, 0.83, 0.91]  ← Preserves relative brightness</code></pre>

            <h3 id="render-shaders">Shader System Architecture</h3>

            <h4>Shader Compilation Process</h4>

            <p>
                Shaders are programs that run on the GPU. They're written in GLSL (OpenGL Shading Language) and compiled at runtime:
            </p>

            <pre><code class="language-glsl">1. Load GLSL source from file
    ↓
2. Compile vertex shader (GL API call)
    ↓
3. Check for compilation errors
    ↓
4. Compile fragment shader
    ↓
5. Link shaders into a program
    ↓
6. Validate program
    ↓
7. Extract uniform locations for C++ access</code></pre>

            <div class="concept-box">
                <h4>Shader Class Design</h4>
                <pre><code class="language-plaintext">class Shader {
public:
    Shader(const std::string& vertPath, const std::string& fragPath);

    void Bind() const;  // Make this shader active
    void Unbind() const;

    // Set uniform values from C++
    void SetInt(const std::string& name, int value);
    void SetFloat(const std::string& name, float value);
    void SetVec3(const std::string& name, const glm::vec3& value);
    void SetMat4(const std::string& name, const glm::mat4& value);

private:
    uint32_t m_ProgramID;
    std::unordered_map&lt;std::string, int&gt; m_UniformCache;  // Uniform name → location
};</code></pre>
            </div>

            <h4>Vertex and Fragment Shader Communication</h4>

            <p>
                Data flows from vertex shader to fragment shader through "varying" variables:
            </p>

            <pre><code class="language-glsl">// Vertex Shader (default.vert):
#version 450 core

layout(location = 0) in vec3 a_Position;
layout(location = 1) in vec3 a_Normal;
layout(location = 2) in vec2 a_TexCoord;

out vec3 v_WorldPos;    // Output to fragment shader
out vec3 v_Normal;      // Output to fragment shader
out vec2 v_TexCoord;    // Output to fragment shader

uniform mat4 u_Model;
uniform mat4 u_View;
uniform mat4 u_Projection;

void main() {
    v_WorldPos = vec3(u_Model * vec4(a_Position, 1.0));
    v_Normal = mat3(transpose(inverse(u_Model))) * a_Normal;
    v_TexCoord = a_TexCoord;

    gl_Position = u_Projection * u_View * vec4(v_WorldPos, 1.0);
}

// Fragment Shader (default.frag):
#version 450 core

in vec3 v_WorldPos;     // Input from vertex shader (interpolated)
in vec3 v_Normal;       // Input from vertex shader (interpolated)
in vec2 v_TexCoord;     // Input from vertex shader (interpolated)

// ... use these values for lighting calculations</code></pre>

            <p>
                The rasterizer automatically interpolates these values across triangle surfaces. For a triangle with vertices at
                positions (0,0), (1,0), (0,1), a fragment in the center gets interpolated values from all three vertices.
            </p>

            <h3 id="render-materials">Material System</h3>

            <h4>What is a Material?</h4>

            <p>
                A material defines how a surface appears by combining:
            </p>

            <ul>
                <li><strong>Shader</strong>: What program to use for rendering</li>
                <li><strong>Properties</strong>: Albedo color, roughness, metallic, etc.</li>
                <li><strong>Textures</strong>: Image maps for detailed appearance</li>
                <li><strong>Render state</strong>: Blending mode, culling, depth testing</li>
            </ul>

            <pre><code class="language-cpp">class Material {
public:
    std::shared_ptr&lt;Shader&gt; shader;

    // PBR properties
    glm::vec4 albedoColor = glm::vec4(1.0f);
    float metallic = 0.0f;
    float roughness = 0.5f;
    float ao = 1.0f;
    glm::vec3 emissive = glm::vec3(0.0f);

    // Texture maps
    std::shared_ptr&lt;Texture&gt; albedoMap;
    std::shared_ptr&lt;Texture&gt; normalMap;
    std::shared_ptr&lt;Texture&gt; metallicRoughnessMap;

    void Bind() {
        shader-&gt;Bind();
        shader-&gt;SetVec4("u_AlbedoColor", albedoColor);
        shader-&gt;SetFloat("u_Metallic", metallic);
        shader-&gt;SetFloat("u_Roughness", roughness);
        shader-&gt;SetFloat("u_AO", ao);

        if (albedoMap) {
            albedoMap-&gt;Bind(0);
            shader-&gt;SetInt("u_AlbedoMap", 0);
            shader-&gt;SetInt("u_HasAlbedoMap", 1);
        } else {
            shader-&gt;SetInt("u_HasAlbedoMap", 0);
        }
        // ... bind other textures
    }
};</code></pre>

            <h4>Renderer Architecture</h4>

            <pre><code class="language-cpp">#pragma once

#include "Camera.h"
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;glm/glm.hpp&gt;

namespace Xi {

    class Shader;
    class Mesh;
    class Material;

    struct LightData {
        enum class Type { Directional, Point, Spot };

        Type type = Type::Directional;
        glm::vec3 position = glm::vec3(0.0f);
        glm::vec3 direction = glm::vec3(0.0f, -1.0f, 0.0f);
        glm::vec3 color = glm::vec3(1.0f);
        float intensity = 1.0f;
        float range = 10.0f;
        float spotAngle = 45.0f;
    };

    class Renderer {
    public:
        Renderer();
        ~Renderer();

        void Init();
        void Shutdown();

        void BeginFrame();  // Clear buffers, reset stats
        void EndFrame();    // Swap buffers

        void SetCamera(const Camera& camera);
        const Camera& GetCamera() const { return m_Camera; }

        // Submit a draw call to the render queue
        void Submit(std::shared_ptr&lt;Mesh&gt; mesh,
                    std::shared_ptr&lt;Material&gt; material,
                    const glm::mat4& transform);

        // Lighting
        void AddLight(const LightData& light);
        void ClearLights();

        // Immediate mode drawing (bypasses queue)
        void DrawMesh(Mesh& mesh, Material& material, const glm::mat4& transform);

        // Default shaders
        std::shared_ptr&lt;Shader&gt; GetDefaultShader() const { return m_DefaultShader; }

        // Statistics
        struct Stats {
            uint32_t drawCalls = 0;
            uint32_t triangles = 0;
        };
        const Stats& GetStats() const { return m_Stats; }

    private:
        void CreateDefaultShaders();
        void SetupLightUniforms(Shader& shader);

        Camera m_Camera;
        std::vector&lt;LightData&gt; m_Lights;

        std::shared_ptr&lt;Shader&gt; m_DefaultShader;
        std::shared_ptr&lt;Shader&gt; m_UnlitShader;

        Stats m_Stats;
    };

}</code></pre>

            <div class="concept-box">
                <h4>Render Queue vs Immediate Mode</h4>
                <p>
                    <strong>Render Queue</strong>: Collect all draw calls during frame, sort by material/distance, then render.
                    This minimizes state changes (shader binds, texture binds) which are expensive.
                </p>
                <p>
                    <strong>Immediate Mode</strong>: Render objects as soon as Submit() is called. Simple but inefficient due to
                    random state changes.
                </p>
                <p>
                    For a production engine, always use a render queue with sorting. Our implementation uses immediate mode for
                    simplicity.
                </p>
            </div>
        </section>

        <section id="physics">
            <h2>Physics Engine: Simulating Reality</h2>

            <p class="section-intro">
                The physics engine is one of the most complex and critical systems in a game engine. It brings the virtual world to life
                by simulating how objects move, collide, and interact based on the laws of physics. In this comprehensive section, we'll
                explore every aspect of physics simulation from first principles to implementation.
            </p>

            <h3>Physics Engine Fundamentals</h3>

            <h4>What is a Physics Engine?</h4>

            <p>
                A physics engine is a software system that simulates physical phenomena in a virtual environment. Unlike rendering, which
                is concerned with how things <em>look</em>, physics is concerned with how things <em>behave</em>. The goal is to create
                believable, predictable motion and interaction.
            </p>

            <div class="physics-box">
                <h4>Why Games Need Physics Engines</h4>
                <p>
                    Without physics simulation, every interaction would need to be hand-animated or scripted. Imagine programming what
                    happens when a grenade bounces off a wall, hits a barrel, which rolls down stairs and knocks over a pile of boxes.
                    The combinatorial explosion of possibilities makes manual scripting impossible.
                </p>
                <p>
                    A physics engine handles this automatically. You define the properties of objects (mass, shape, friction) and the
                    engine computes realistic motion and collision responses in real-time.
                </p>
            </div>

            <h4>The Physics Simulation Loop</h4>

            <p>
                Every physics engine follows the same fundamental update loop. Understanding this loop is crucial to understanding how
                physics simulation works:
            </p>

            <div class="ascii-diagram">  1. INTEGRATE FORCES & VELOCITIES
   │
   │  - Apply gravity: F = m * g
   │  - Apply user forces (explosions, wind, etc.)
   │  - Update velocities: v = v + (F/m) * dt
   │  - Update positions: p = p + v * dt
   │
   ▼

  2. DETECT COLLISIONS
   │
   │  - Broad Phase: Find potential collision pairs
   │  - Narrow Phase: Test pairs for actual intersection
   │  - Generate collision manifolds (contact points, normals, depth)
   │
   ▼

  3. RESOLVE COLLISIONS
   │
   │  - Separate penetrating objects (position correction)
   │  - Apply impulses to bounce/slide objects apart
   │  - Apply friction forces
   │
   ▼

  4. REPEAT NEXT FRAME</div>

            <p>
                This three-step process (integrate → detect → resolve) runs every physics timestep, typically 60 times per second.
                The order matters: we integrate first to predict where objects will move, then detect and resolve collisions to
                correct any invalid states.
            </p>

            <h4>Fixed Timestep vs Variable Timestep</h4>

            <p>
                One of the most important concepts in physics simulation is the difference between fixed and variable timesteps.
                This choice fundamentally affects the stability and determinism of your simulation.
            </p>

            <div class="comparison-box-vertical">
                <div class="comparison-left">
                    <h4>Variable Timestep</h4>
                    <pre><code class="language-cpp">// Use actual frame time
float dt = GetDeltaTime();
UpdatePhysics(dt);</code></pre>
                    <p><strong>Problems:</strong></p>
                    <ul>
                        <li>Non-deterministic: different frame rates give different results</li>
                        <li>Unstable: large dt can cause tunneling (objects passing through walls)</li>
                        <li>Spiral of death: lag causes large dt, which causes more lag</li>
                    </ul>
                </div>
                <div class="comparison-right">
                    <h4>Fixed Timestep</h4>
                    <pre><code class="language-cpp">const float FIXED_DT = 1.0f/60.0f;
accumulator += GetDeltaTime();
while (accumulator >= FIXED_DT) {
    UpdatePhysics(FIXED_DT);
    accumulator -= FIXED_DT;
}</code></pre>
                    <p><strong>Benefits:</strong></p>
                    <ul>
                        <li>Deterministic: same inputs always produce same outputs</li>
                        <li>Stable: consistent dt prevents integration errors</li>
                        <li>Predictable: easier to tune physics parameters</li>
                    </ul>
                </div>
            </div>

            <div class="formula-box">
                <h4>Why Fixed Timestep is Critical</h4>
                <p>
                    Consider a ball falling with gravity. With variable timestep:
                </p>
                <code>
Frame 1: dt = 0.016s  →  velocity = 0 + 9.8 * 0.016 = 0.157 m/s
Frame 2: dt = 0.033s  →  velocity = 0.157 + 9.8 * 0.033 = 0.480 m/s  (lag spike!)
                </code>
                <p>
                    The lag spike causes the ball to accelerate faster than it should. With fixed timestep, physics always runs
                    at exactly 60 FPS internally, regardless of rendering frame rate. This ensures consistent, reproducible behavior.
                </p>
            </div>

            <h3>Collision Detection Theory</h3>

            <p>
                Collision detection is the process of determining whether two objects in space are overlapping or touching. This sounds
                simple but is actually one of the most performance-critical and algorithmically complex parts of a physics engine.
            </p>

            <h4>Broad Phase vs Narrow Phase</h4>

            <p>
                Testing every object against every other object is O(n²) complexity. For 1000 objects, that's 500,000 collision tests
                per frame! Physics engines solve this with a two-phase approach:
            </p>

            <div class="physics-box">
                <h4>Broad Phase Collision Detection</h4>
                <p>
                    The broad phase quickly finds <em>potential</em> collision pairs using cheap, conservative tests. The goal is to
                    eliminate obviously non-colliding pairs as fast as possible.
                </p>
                <p><strong>Common Broad Phase Algorithms:</strong></p>
                <ul>
                    <li><strong>Brute Force</strong>: Test all pairs. Simple but O(n²). Used in Xi Engine for simplicity.</li>
                    <li><strong>Spatial Grid</strong>: Divide world into cells, only test objects in same/adjacent cells.</li>
                    <li><strong>BVH (Bounding Volume Hierarchy)</strong>: Tree of bounding boxes, prune entire subtrees.</li>
                    <li><strong>Sweep and Prune</strong>: Sort objects along axis, only test overlapping ranges.</li>
                </ul>
            </div>

            <div class="physics-box">
                <h4>Narrow Phase Collision Detection</h4>
                <p>
                    The narrow phase performs precise collision tests on pairs identified by the broad phase. These tests are
                    shape-specific and more expensive, but we only run them on objects that are actually close to each other.
                </p>
                <p>
                    The narrow phase must compute not just whether objects intersect, but also:
                </p>
                <ul>
                    <li><strong>Contact Point</strong>: Where objects are touching</li>
                    <li><strong>Contact Normal</strong>: The direction to push objects apart</li>
                    <li><strong>Penetration Depth</strong>: How far objects have overlapped</li>
                </ul>
            </div>

            <h4>Spatial Partitioning Concepts</h4>

            <p>
                While Xi Engine uses brute force O(n²) collision detection for simplicity, production engines use spatial partitioning
                to reduce complexity. Here's how these work conceptually:
            </p>

            <div class="ascii-diagram">Spatial Grid:
┌────┬────┬────┬────┐
│ A  │    │    │  D │
├────┼────┼────┼────┤
│    │ B,C│    │    │   A only tests against objects
│    │    │    │    │   in its cell (none = 0 tests)
├────┼────┼────┼────┤
│    │    │  E │    │   B tests against C (same cell)
│    │    │    │    │   = 1 test instead of 5
└────┴────┴────┴────┘

BVH (Bounding Volume Hierarchy):
        [Root AABB]
          /      \
    [Left AABB] [Right AABB]
      /    \       /      \
    [A] [B,C]   [D]      [E]

To test A, we first check Root.
If it hits Left, we check A and [B,C].
We never test against Right subtree!</div>

            <p>
                Xi Engine's brute force approach tests all N*(N-1)/2 pairs. For 100 objects, that's 4,950 tests per frame. Spatial
                partitioning can reduce this to hundreds or even tens of tests. However, brute force is simpler to implement and
                works fine for small to medium scenes (up to ~200 objects).
            </p>

            <h3>AABB (Axis-Aligned Bounding Box) Collision - DETAILED</h3>

            <p>
                The AABB is the workhorse of collision detection. Understanding AABBs deeply is essential for understanding physics engines.
            </p>

            <h4>What is an AABB?</h4>

            <p>
                An AABB (Axis-Aligned Bounding Box) is the simplest type of bounding volume: a rectangular box whose edges are parallel
                to the world's X, Y, and Z axes. "Axis-aligned" means the box never rotates - it's always aligned with the world axes,
                even if the object inside it rotates.
            </p>

            <div class="ascii-diagram">2D AABB Example:

   Y
   ^
   │      max (x₂, y₂)
   │         ┌─────────┐
   │         │         │
   │         │  AABB   │
   │         │         │
   │         └─────────┘
   │    min (x₁, y₁)
   │
   └────────────────────> X

3D AABB Example:

        max (x₂, y₂, z₂)
          ┌────────┐
         ╱│       ╱│
        ┌─┼──────┐ │  The box is defined by just
        │ │      │ │  two points: minimum and maximum
        │ └──────┼─┘  corners in 3D space
        │╱       │╱
        └────────┘
   min (x₁, y₁, z₁)</div>

            <h4>Why Use AABBs?</h4>

            <div class="physics-box">
                <h4>Advantages of AABBs</h4>
                <ul>
                    <li><strong>Extremely Fast to Test</strong>: AABB vs AABB test is just 6 comparisons (2 per axis)</li>
                    <li><strong>Minimal Memory</strong>: Only need to store 2 vec3s (min and max points)</li>
                    <li><strong>Easy to Update</strong>: When object moves, just recalculate min/max</li>
                    <li><strong>Good Approximation</strong>: For many objects, AABB closely fits the actual shape</li>
                    <li><strong>Never Degenerate</strong>: Unlike some collision shapes, AABBs always work</li>
                </ul>
                <h4>Disadvantages</h4>
                <ul>
                    <li><strong>Can't Rotate</strong>: If object rotates, AABB must grow to contain it (becomes loose fit)</li>
                    <li><strong>Conservative</strong>: May report collisions for objects that aren't actually touching</li>
                    <li><strong>Poor for Thin Objects</strong>: A sword rotated 45° has huge AABB but small actual volume</li>
                </ul>
            </div>

            <h4>AABB Data Structure</h4>

            <p>
                Here's the actual AABB implementation from <code>Engine/Physics/Collider.h</code>:
            </p>

            <pre><code class="language-cpp">#pragma once

#include &lt;glm/glm.hpp&gt;

namespace Xi {

    // AABB collision structure
    struct AABB {
        glm::vec3 min = glm::vec3(0.0f);  // Minimum corner (x₁, y₁, z₁)
        glm::vec3 max = glm::vec3(0.0f);  // Maximum corner (x₂, y₂, z₂)

        AABB() = default;
        AABB(const glm::vec3& min, const glm::vec3& max) : min(min), max(max) {}

        // Get the center point of the AABB
        glm::vec3 GetCenter() const { return (min + max) * 0.5f; }

        // Get half-extents (distance from center to edge on each axis)
        glm::vec3 GetExtents() const { return (max - min) * 0.5f; }

        // Get full size on each axis
        glm::vec3 GetSize() const { return max - min; }

        // Test if a point is inside the AABB
        bool Contains(const glm::vec3& point) const {
            return point.x >= min.x && point.x <= max.x &&
                   point.y >= min.y && point.y <= max.y &&
                   point.z >= min.z && point.z <= max.z;
        }

        // Test if two AABBs intersect (fast test, returns bool only)
        bool Intersects(const AABB& other) const {
            return min.x <= other.max.x && max.x >= other.min.x &&
                   min.y <= other.max.y && max.y >= other.min.y &&
                   min.z <= other.max.z && max.z >= other.min.z;
        }

        // Grow AABB to contain a point
        void Expand(const glm::vec3& point) {
            min = glm::min(min, point);
            max = glm::max(max, point);
        }

        // Grow AABB to contain another AABB
        void Expand(const AABB& other) {
            min = glm::min(min, other.min);
            max = glm::max(max, other.max);
        }
    };

}</code></pre>

            <h4>AABB-AABB Intersection Test: The Separating Axis Theorem</h4>

            <p>
                The AABB intersection test is based on the <strong>Separating Axis Theorem (SAT)</strong>. This theorem states:
            </p>

            <div class="formula-box">
                <h4>Separating Axis Theorem</h4>
                <p>
                    Two convex objects do NOT intersect if and only if there exists an axis along which the projections of the
                    objects do not overlap.
                </p>
                <p>
                    Conversely: if the projections overlap on ALL axes, the objects MUST be intersecting.
                </p>
            </div>

            <p>
                For AABBs, we test three axes (X, Y, Z). If the boxes overlap on all three axes, they're colliding. If they're
                separated on any axis, they're not colliding.
            </p>

            <div class="ascii-diagram">Separating Axis Example (2D):

Test X-axis:
    Box A           Box B
  ├──────┤       ├──────┤
  ▼      ▼       ▼      ▼
  ━━━━━━━━       ━━━━━━━━
 a.min a.max    b.min b.max

  Overlap on X? YES (a.max >= b.min && a.min <= b.max)

Test Y-axis:
  Box A
  ━━━━  ← a.max


  ━━━━  ← a.min

  Box B
          ━━━━  ← b.max

          ━━━━  ← b.min

  Overlap on Y? NO (a.max < b.min)

Result: NOT colliding (separated on Y-axis)</div>

            <h4>The AABB-AABB Test Explained Line by Line</h4>

            <p>
                Let's break down the intersection test from the code above:
            </p>

            <pre><code class="language-cpp">bool Intersects(const AABB& other) const {
    return min.x <= other.max.x && max.x >= other.min.x &&  // X-axis test
           min.y <= other.max.y && max.y >= other.min.y &&  // Y-axis test
           min.z <= other.max.z && max.z >= other.min.z;    // Z-axis test
}</code></pre>

            <p>
                For each axis, we ask: "Do the intervals overlap?" An interval overlaps if:
            </p>

            <div class="formula-box">
                <h4>Interval Overlap Condition</h4>
                <code>
Intervals [a.min, a.max] and [b.min, b.max] overlap if:
    a.min <= b.max  AND  a.max >= b.min

Why? Consider all cases:
    1. A entirely before B:  a.max < b.min  → NO overlap
    2. A entirely after B:   a.min > b.max  → NO overlap
    3. Any other case:                      → OVERLAP

So overlap means: NOT (a.max < b.min) AND NOT (a.min > b.max)
Which simplifies to: a.max >= b.min AND a.min <= b.max
                </code>
            </div>

            <p>
                We test this condition on all three axes. All three must be true for collision. This is an AND operation, so if
                any axis shows separation, we immediately return false (short-circuit evaluation).
            </p>

            <h4>Computing Collision Information: TestAABBAABB Function</h4>

            <p>
                The simple <code>Intersects()</code> method only returns true/false. For physics simulation, we need more information:
                where are they touching, how deep is the penetration, and in what direction should we separate them? This is handled
                by the <code>TestAABBAABB()</code> function in <code>PhysicsWorld.cpp</code>:
            </p>

            <pre><code class="language-cpp">bool PhysicsWorld::TestAABBAABB(const AABB& a, const AABB& b, CollisionInfo& info) {
    // First, quick rejection test
    if (!a.Intersects(b)) return false;

    // Boxes are intersecting - compute penetration depth on each axis
    glm::vec3 overlap;
    overlap.x = glm::min(a.max.x, b.max.x) - glm::max(a.min.x, b.min.x);
    overlap.y = glm::min(a.max.y, b.max.y) - glm::max(a.min.y, b.min.y);
    overlap.z = glm::min(a.max.z, b.max.z) - glm::max(a.min.z, b.min.z);

    // Find axis of minimum penetration (this is the contact normal direction)
    if (overlap.x < overlap.y && overlap.x < overlap.z) {
        // X-axis has minimum penetration
        info.penetrationDepth = overlap.x;
        info.contactNormal = (a.GetCenter().x < b.GetCenter().x) ? glm::vec3(-1, 0, 0) : glm::vec3(1, 0, 0);
    } else if (overlap.y < overlap.z) {
        // Y-axis has minimum penetration
        info.penetrationDepth = overlap.y;
        info.contactNormal = (a.GetCenter().y < b.GetCenter().y) ? glm::vec3(0, -1, 0) : glm::vec3(0, 1, 0);
    } else {
        // Z-axis has minimum penetration
        info.penetrationDepth = overlap.z;
        info.contactNormal = (a.GetCenter().z < b.GetCenter().z) ? glm::vec3(0, 0, -1) : glm::vec3(0, 0, 1);
    }

    // Contact point is average of the two centers (approximation)
    info.contactPoint = (a.GetCenter() + b.GetCenter()) * 0.5f;
    return true;
}</code></pre>

            <h4>Understanding Penetration Depth Calculation</h4>

            <p>
                When two AABBs overlap, they penetrate into each other by some amount on each axis. We compute the overlap
                distance on each axis:
            </p>

            <div class="ascii-diagram">Penetration Depth Example (1D):

Box A:     ├──────────┤
Box B:           ├──────────┤

Combined:  ├─────╋════╋────┤
                 ↑    ↑
              overlap region

overlap = min(a.max, b.max) - max(a.min, b.min)
        = min of right edges - max of left edges
        = size of the intersection interval</div>

            <p>
                We compute this for all three axes, then choose the <strong>axis of minimum penetration</strong>. Why? Because
                that's the direction we need to move the least to separate the boxes. Moving apart along this axis is the most
                efficient way to resolve the collision.
            </p>

            <h4>Computing the Contact Normal</h4>

            <p>
                The contact normal is the direction we push objects apart. Once we know the axis of minimum penetration, we need
                to determine the direction along that axis. We do this by comparing the centers of the boxes:
            </p>

            <div class="formula-box">
                <h4>Contact Normal Direction</h4>
                <code>
If X-axis has minimum penetration:
    If A's center is left of B's center:  normal = (-1, 0, 0)  ← Push A left
    If A's center is right of B's center: normal = (+1, 0, 0)  ← Push A right

Similar logic for Y and Z axes.

The normal always points FROM B TOWARDS A.
                </code>
            </div>

            <h4>AABB Utility Functions Explained</h4>

            <p>
                Let's examine each utility function in detail:
            </p>

            <div class="physics-box">
                <h4>GetCenter()</h4>
                <pre><code class="language-cpp">glm::vec3 GetCenter() const { return (min + max) * 0.5f; }</code></pre>
                <p>
                    Returns the center point of the AABB. This is simply the midpoint between min and max corners.
                    Example: min=(0,0,0), max=(4,4,4) → center=(2,2,2)
                </p>
            </div>

            <div class="physics-box">
                <h4>GetExtents()</h4>
                <pre><code class="language-cpp">glm::vec3 GetExtents() const { return (max - min) * 0.5f; }</code></pre>
                <p>
                    Returns the half-extents (distance from center to edge on each axis). This is useful for constructing
                    AABBs from center + extents representation. Example: min=(0,0,0), max=(4,4,4) → extents=(2,2,2)
                </p>
            </div>

            <div class="physics-box">
                <h4>GetSize()</h4>
                <pre><code class="language-cpp">glm::vec3 GetSize() const { return max - min; }</code></pre>
                <p>
                    Returns the full size of the AABB on each axis. Example: min=(0,0,0), max=(4,4,4) → size=(4,4,4).
                    Note: size = extents * 2
                </p>
            </div>

            <div class="physics-box">
                <h4>Contains(point) - Point-in-Box Test</h4>
                <pre><code class="language-cpp">bool Contains(const glm::vec3& point) const {
    return point.x >= min.x && point.x <= max.x &&
           point.y >= min.y && point.y <= max.y &&
           point.z >= min.z && point.z <= max.z;
}</code></pre>
                <p>
                    Tests if a point is inside the AABB. A point is inside if it's between min and max on all three axes.
                    This is used for mouse picking, trigger volumes, and spatial queries.
                </p>
            </div>

            <div class="physics-box">
                <h4>Expand() - Growing AABBs</h4>
                <pre><code class="language-cpp">void Expand(const glm::vec3& point) {
    min = glm::min(min, point);  // Move min corner to include point
    max = glm::max(max, point);  // Move max corner to include point
}

void Expand(const AABB& other) {
    min = glm::min(min, other.min);
    max = glm::max(max, other.max);
}</code></pre>
                <p>
                    Grows the AABB to contain a point or another AABB. This is used for:
                </p>
                <ul>
                    <li>Building BVH trees (merge child AABBs into parent)</li>
                    <li>Computing bounding boxes for complex meshes (expand to include each vertex)</li>
                    <li>Dynamic AABB updates (expand to include new positions)</li>
                </ul>
            </div>

            <h3>Sphere Collision Detection - DETAILED</h3>

            <p>
                Sphere colliders are the second fundamental collision primitive. While AABBs are best for box-shaped objects, spheres
                are perfect for approximately round objects like balls, planets, or explosions.
            </p>

            <h4>Bounding Sphere Structure</h4>

            <p>
                A sphere is even simpler than an AABB - it's defined by just a center point and a radius:
            </p>

            <pre><code class="language-cpp">// Sphere collision structure from Engine/Physics/Collider.h
struct BoundingSphere {
    glm::vec3 center = glm::vec3(0.0f);  // Center point in world space
    float radius = 0.5f;                 // Distance from center to surface

    BoundingSphere() = default;
    BoundingSphere(const glm::vec3& c, float r) : center(c), radius(r) {}

    // Test if a point is inside the sphere
    bool Contains(const glm::vec3& point) const {
        return glm::length(point - center) <= radius;
    }

    // Test if two spheres intersect
    bool Intersects(const BoundingSphere& other) const {
        float distance = glm::length(other.center - center);
        return distance <= (radius + other.radius);
    }

    // Sphere vs AABB intersection (uses closest point algorithm)
    bool Intersects(const AABB& aabb) const {
        // Find closest point on AABB to sphere center
        glm::vec3 closest;
        closest.x = glm::clamp(center.x, aabb.min.x, aabb.max.x);
        closest.y = glm::clamp(center.y, aabb.min.y, aabb.max.y);
        closest.z = glm::clamp(center.z, aabb.min.z, aabb.max.z);

        float distanceSquared = glm::dot(closest - center, closest - center);
        return distanceSquared <= (radius * radius);
    }
}</code></pre>

            <h4>Sphere-Sphere Collision Test</h4>

            <p>
                The sphere-sphere test is the simplest collision test in all of physics simulation. Two spheres collide if the
                distance between their centers is less than the sum of their radii:
            </p>

            <div class="formula-box">
                <h4>Sphere-Sphere Intersection</h4>
                <code>
distance = ||centerB - centerA||  (Euclidean distance)
sumRadii = radiusA + radiusB

Collision if: distance < sumRadii

Why? If distance = sumRadii, the spheres are exactly touching.
     If distance < sumRadii, they must be overlapping.
     If distance > sumRadii, there's a gap between them.
                </code>
            </div>

            <div class="ascii-diagram">Sphere-Sphere Collision:

  NOT Colliding:              Colliding:
       ___                        ___
      /   \      ___             /   \___
     |  A  |    /   \           |  A /   \
      \___/    |  B  |           \__| B  |
                \___/                \___/

  distance > rA + rB         distance < rA + rB
                             Penetration = (rA + rB) - distance</div>

            <p>
                Here's the actual implementation from <code>PhysicsWorld.cpp</code>:
            </p>

            <pre><code class="language-cpp">bool PhysicsWorld::TestSphereSphere(const BoundingSphere& a, const BoundingSphere& b, CollisionInfo& info) {
    // Vector from A to B
    glm::vec3 diff = b.center - a.center;

    // Distance between centers
    float distance = glm::length(diff);

    // Sum of radii
    float sumRadii = a.radius + b.radius;

    // Early rejection: no collision if distance > sum of radii
    if (distance > sumRadii) return false;

    // Collision detected - compute collision info
    info.penetrationDepth = sumRadii - distance;

    // Contact normal points from A towards B
    // Special case: if spheres are at same position, use arbitrary up vector
    info.contactNormal = (distance > 0.0001f) ? diff / distance : glm::vec3(0, 1, 0);

    // Contact point is on the surface of sphere A, along the normal
    info.contactPoint = a.center + info.contactNormal * a.radius;

    return true;
}</code></pre>

            <h4>Understanding the Contact Normal Calculation</h4>

            <p>
                The contact normal is the direction to push objects apart. For spheres, this is simply the normalized vector from
                A's center to B's center. Why? Because that's the shortest path to separate them.
            </p>

            <div class="formula-box">
                <h4>Contact Normal for Spheres</h4>
                <code>
normal = (centerB - centerA) / ||centerB - centerA||

This is the unit vector pointing from A to B.

Edge case: if distance ≈ 0 (spheres have same center),
           we use an arbitrary direction like (0, 1, 0)
           to avoid division by zero.
                </code>
            </div>

            <h4>Sphere-AABB Collision Test - The Closest Point Algorithm</h4>

            <p>
                Testing a sphere against an AABB is more complex than sphere-sphere or AABB-AABB. The key insight is to find the
                closest point on the AABB to the sphere's center, then test if that point is within the sphere's radius.
            </p>

            <div class="ascii-diagram">Sphere-AABB Closest Point:

        ┌─────────────┐
        │             │
        │    AABB     │     ___
        │             │    /   \
        │         ●───┼───→  S  |  ← Sphere center
        │      closest│    \___/
        │       point │
        └─────────────┘

The closest point on the AABB is found by clamping
the sphere center to the AABB's bounds on each axis.</div>

            <p>
                Here's the algorithm step by step:
            </p>

            <pre><code class="language-cpp">bool PhysicsWorld::TestSphereAABB(const BoundingSphere& sphere, const AABB& aabb, CollisionInfo& info) {
    // Step 1: Find closest point on AABB to sphere center
    glm::vec3 closest;
    closest.x = glm::clamp(sphere.center.x, aabb.min.x, aabb.max.x);
    closest.y = glm::clamp(sphere.center.y, aabb.min.y, aabb.max.y);
    closest.z = glm::clamp(sphere.center.z, aabb.min.z, aabb.max.z);

    // Step 2: Compute vector from closest point to sphere center
    glm::vec3 diff = sphere.center - closest;

    // Step 3: Compute distance squared (avoid expensive sqrt)
    float distanceSquared = glm::dot(diff, diff);

    // Step 4: Test if distance is within sphere radius
    if (distanceSquared > sphere.radius * sphere.radius) return false;

    // Collision detected - compute collision info
    float distance = std::sqrt(distanceSquared);
    info.penetrationDepth = sphere.radius - distance;

    // Normal points from AABB (closest point) towards sphere center
    info.contactNormal = (distance > 0.0001f) ? diff / distance : glm::vec3(0, 1, 0);

    info.contactPoint = closest;

    return true;
}</code></pre>

            <h4>Why Clamp Instead of Complex Geometry?</h4>

            <p>
                The <code>clamp()</code> function is key to this algorithm. It constrains a value to a range:
            </p>

            <div class="formula-box">
                <h4>Clamp Function</h4>
                <code>
clamp(value, min, max) returns:
    - min     if value < min
    - max     if value > max
    - value   otherwise

For each axis:
    closest.x = clamp(sphere.center.x, aabb.min.x, aabb.max.x)

This gives us the closest point on the AABB surface to the sphere center.
                </code>
            </div>

            <div class="ascii-diagram">Clamp Examples (1D):

Sphere center left of AABB:
     S         [=======AABB=======]
  center     min                max
     ●────────→●
              closest = min

Sphere center inside AABB:
          [====S===AABB=====]
              center
               ●
            closest = center (already on surface)

Sphere center right of AABB:
     [=======AABB=======]         S
                                center
                        ●←────────●
                     closest = max</div>

            <h3>Collision Response - DETAILED</h3>

            <p>
                Detecting collisions is only half the battle. Once we know two objects are colliding, we need to respond
                appropriately: separate them (position correction) and apply forces to make them bounce or slide (impulse-based response).
            </p>

            <h4>Position Correction - Separating Penetrating Objects</h4>

            <p>
                When two objects overlap, they're in an invalid state - in the real world, solid objects can't occupy the same space.
                The first step of collision response is to move the objects apart so they're just touching, not overlapping.
            </p>

            <div class="physics-box">
                <h4>Why We Need Position Correction</h4>
                <p>
                    Even with careful integration, objects can end up overlapping due to:
                </p>
                <ul>
                    <li><strong>Numerical error</strong>: Floating-point math isn't perfect</li>
                    <li><strong>High velocities</strong>: Objects moving very fast can tunnel through thin objects</li>
                    <li><strong>Complex scenarios</strong>: Multiple simultaneous collisions can cause penetration</li>
                </ul>
                <p>
                    If we don't correct position, objects will "sink" into each other over multiple frames, looking broken.
                </p>
            </div>

            <h4>Mass Ratio - Why Lighter Objects Move More</h4>

            <p>
                When separating objects, we don't just push them apart equally. We use their mass ratio to determine how much
                each object moves. This follows Newton's third law: forces are equal and opposite, but acceleration depends on mass.
            </p>

            <div class="formula-box">
                <h4>Position Correction with Mass Ratio</h4>
                <code>
totalMass = massA + massB

ratioA = massB / totalMass  (A moves based on B's mass)
ratioB = massA / totalMass  (B moves based on A's mass)

positionA += contactNormal * penetrationDepth * ratioA
positionB -= contactNormal * penetrationDepth * ratioB

Why? If massB >> massA (B is much heavier):
    ratioA ≈ 1 (light object moves almost all the distance)
    ratioB ≈ 0 (heavy object barely moves)

This makes the Earth move imperceptibly when you jump on it!
                </code>
            </div>

            <p>
                Here's the actual position correction code from <code>PhysicsWorld.cpp ResolveCollisions()</code>:
            </p>

            <pre><code class="language-cpp">// Calculate masses (Static bodies have infinite mass, treated as 0 here)
float massA = (rbA && rbA->type == RigidBodyType::Dynamic) ? rbA->mass : 0.0f;
float massB = (rbB && rbB->type == RigidBodyType::Dynamic) ? rbB->mass : 0.0f;
float totalMass = massA + massB;

if (totalMass <= 0.0f) continue;  // Both static, can't move

// Position correction ratios
float ratioA = (massA > 0.0f) ? massB / totalMass : 0.0f;
float ratioB = (massB > 0.0f) ? massA / totalMass : 0.0f;

// Move objects apart along contact normal
if (transformA && rbA && rbA->type == RigidBodyType::Dynamic) {
    transformA->position += info.contactNormal * info.penetrationDepth * ratioA;
}
if (transformB && rbB && rbB->type == RigidBodyType::Dynamic) {
    transformB->position -= info.contactNormal * info.penetrationDepth * ratioB;
}</code></pre>

            <h4>Impulse-Based Response - Making Objects Bounce</h4>

            <p>
                After separating objects, we need to change their velocities so they bounce apart (or slide, for low-friction collisions).
                This is done using <strong>impulses</strong> - instantaneous changes in velocity.
            </p>

            <h4>What is an Impulse vs a Force?</h4>

            <div class="comparison-box-vertical">
                <div class="comparison-left">
                    <h4>Force</h4>
                    <pre><code class="language-cpp">// Force is applied over time
// F = m * a
acceleration = force / mass;
velocity += acceleration * dt;

// Example: gravity
rb.force += glm::vec3(0, -9.8, 0) * rb.mass;
// Applied every frame</code></pre>
                    <p>
                        Forces are continuous - they're applied over time (F*dt). Examples: gravity, wind, thrust.
                    </p>
                </div>
                <div class="comparison-right">
                    <h4>Impulse</h4>
                    <pre><code class="language-cpp">// Impulse is instant velocity change
// J = m * Δv  →  Δv = J / m
velocity += impulse / mass;

// Example: collision
glm::vec3 impulse = j * contactNormal;
rb.velocity += impulse / rb.mass;
// Applied once, right now</code></pre>
                    <p>
                        Impulses are instantaneous - they change velocity immediately. Examples: collisions, explosions, jumps.
                    </p>
                </div>
            </div>

            <h4>Computing the Collision Impulse</h4>

            <p>
                The collision impulse is computed using the principle of conservation of momentum and the coefficient of restitution
                (bounciness). Here's the physics:
            </p>

            <div class="formula-box">
                <h4>Impulse Calculation Formula</h4>
                <code>
Step 1: Compute relative velocity along contact normal
    relativeVel = velocityA - velocityB
    velAlongNormal = dot(relativeVel, contactNormal)

Step 2: If objects moving apart, don't apply impulse
    if (velAlongNormal > 0) return;  // Already separating

Step 3: Compute impulse magnitude (j)
    e = restitution coefficient (0 = stick, 1 = perfect bounce)
    j = -(1 + e) * velAlongNormal / (1/massA + 1/massB)

Step 4: Apply impulse
    impulse = j * contactNormal
    velocityA += impulse / massA
    velocityB -= impulse / massB

This formula comes from solving:
    Conservation of momentum: m₁v₁ + m₂v₂ = m₁v₁' + m₂v₂'
    Restitution relation:     v₂' - v₁' = -e(v₂ - v₁)
                </code>
            </div>

            <p>
                Here's the actual implementation from <code>PhysicsWorld.cpp</code>:
            </p>

            <pre><code class="language-cpp">// Velocity response (impulse-based collision resolution)
if (rbA && rbB) {
    // Step 1: Compute relative velocity
    glm::vec3 relativeVel = rbA->velocity - rbB->velocity;
    float velAlongNormal = glm::dot(relativeVel, info.contactNormal);

    // Step 2: Don't resolve if objects are moving apart
    if (velAlongNormal > 0) continue;

    // Step 3: Compute restitution (bounciness)
    float restitution = glm::min(rbA->bounciness, rbB->bounciness);

    // Step 4: Compute impulse magnitude
    float j = -(1.0f + restitution) * velAlongNormal;
    j /= (1.0f / massA + 1.0f / massB);

    // Step 5: Apply impulse
    glm::vec3 impulse = j * info.contactNormal;

    if (rbA->type == RigidBodyType::Dynamic) {
        rbA->velocity += impulse / massA;
    }
    if (rbB->type == RigidBodyType::Dynamic) {
        rbB->velocity -= impulse / massB;
    }
}</code></pre>

            <h4>Understanding Restitution (Bounciness)</h4>

            <p>
                The restitution coefficient determines how bouncy a collision is:
            </p>

            <div class="physics-box">
                <h4>Restitution Values</h4>
                <ul>
                    <li><strong>e = 0.0</strong>: Perfectly inelastic (objects stick together, no bounce)</li>
                    <li><strong>e = 0.3</strong>: Low bounce (like a beanbag hitting the ground)</li>
                    <li><strong>e = 0.5</strong>: Medium bounce (basketball)</li>
                    <li><strong>e = 0.8</strong>: High bounce (superball)</li>
                    <li><strong>e = 1.0</strong>: Perfectly elastic (theoretical perfect bounce, no energy lost)</li>
                </ul>
                <p>
                    In real physics engines, restitution > 1.0 adds energy to the system (impossible in real life but useful
                    for special effects). We use <code>min(rbA->bounciness, rbB->bounciness)</code> so the less bouncy material
                    dominates (a rubber ball hitting concrete bounces less than hitting rubber).
                </p>
            </div>

            <h4>Friction (Basic Implementation)</h4>

            <p>
                Xi Engine includes a basic friction parameter in the RigidBody component. Full friction simulation involves
                computing tangential impulses (perpendicular to the contact normal), but our simplified implementation just
                applies drag to velocities. Production engines use Coulomb friction models.
            </p>

            <h3>Rigid Body Dynamics - DETAILED</h3>

            <p>
                Rigid bodies are the physics representation of game objects. A rigid body is an idealized solid object that doesn't
                deform - it maintains its shape under all forces. This simplification makes physics simulation tractable in real-time.
            </p>

            <h4>The RigidBody Component</h4>

            <p>
                Here's the complete RigidBody structure from <code>Engine/ECS/Components/RigidBody.h</code>:
            </p>

            <pre><code class="language-cpp">#pragma once

#include &lt;glm/glm.hpp&gt;

namespace Xi {

    enum class RigidBodyType {
        Static,      // Never moves (walls, terrain)
        Kinematic,   // Moves but not affected by forces (moving platforms)
        Dynamic      // Full physics simulation (player, enemies, objects)
    };

    struct RigidBody {
        RigidBodyType type = RigidBodyType::Dynamic;

        float mass = 1.0f;              // Mass in kg (affects acceleration)
        float drag = 0.0f;              // Linear drag coefficient (air resistance)
        float angularDrag = 0.05f;      // Rotational drag (spinning slows down)

        glm::vec3 velocity = glm::vec3(0.0f);         // Linear velocity (m/s)
        glm::vec3 angularVelocity = glm::vec3(0.0f);  // Angular velocity (rad/s)

        bool useGravity = true;
        glm::vec3 gravity = glm::vec3(0.0f, -9.81f, 0.0f);  // Gravity acceleration

        // Constraints (freeze axes to prevent movement/rotation)
        bool freezePositionX = false;
        bool freezePositionY = false;
        bool freezePositionZ = false;
        bool freezeRotationX = false;
        bool freezeRotationY = false;
        bool freezeRotationZ = false;

        // Physics material properties
        float friction = 0.5f;      // Surface friction (0 = ice, 1 = rubber)
        float bounciness = 0.0f;    // Restitution coefficient (0 = no bounce, 1 = perfect bounce)

        // Forces to apply this frame (cleared each frame after integration)
        glm::vec3 force = glm::vec3(0.0f);
        glm::vec3 torque = glm::vec3(0.0f);

        // Add a continuous force (accumulates until integration)
        void AddForce(const glm::vec3& f) {
            force += f;
        }

        // Add an instantaneous impulse (immediate velocity change)
        void AddImpulse(const glm::vec3& impulse) {
            if (mass > 0.0f) {
                velocity += impulse / mass;
            }
        }

        // Add a torque (rotational force)
        void AddTorque(const glm::vec3& t) {
            torque += t;
        }
    };

}</code></pre>

            <h4>Body Types Explained</h4>

            <div class="physics-box">
                <h4>Static Bodies</h4>
                <p>
                    Static bodies never move. They have infinite mass and zero velocity. Use for:
                </p>
                <ul>
                    <li>Terrain and level geometry</li>
                    <li>Walls and buildings</li>
                    <li>Any permanent fixture</li>
                </ul>
                <p>
                    Physics engines optimize static bodies heavily - they're often in a separate spatial structure and never
                    participate in integration. Only dynamic bodies collide with them.
                </p>
            </div>

            <div class="physics-box">
                <h4>Kinematic Bodies</h4>
                <p>
                    Kinematic bodies move (you can set their position/velocity) but aren't affected by forces or collisions.
                    Use for:
                </p>
                <ul>
                    <li>Moving platforms (you control movement via script/animation)</li>
                    <li>Doors and elevators</li>
                    <li>Scripted moving obstacles</li>
                    <li>Character controllers (you want precise control, not physics-driven)</li>
                </ul>
                <p>
                    Kinematic bodies can push dynamic bodies but aren't pushed back. They ignore gravity and forces.
                </p>
            </div>

            <div class="physics-box">
                <h4>Dynamic Bodies</h4>
                <p>
                    Dynamic bodies are fully simulated. They respond to forces, gravity, and collisions. Use for:
                </p>
                <ul>
                    <li>Physics-driven objects (crates, barrels, debris)</li>
                    <li>Projectiles</li>
                    <li>Vehicles</li>
                    <li>Ragdolls</li>
                </ul>
                <p>
                    Dynamic bodies are the most expensive - they participate in all physics calculations.
                </p>
            </div>

            <h4>Integration - The Euler Method</h4>

            <p>
                Integration is the process of updating positions and velocities based on forces. We use the semi-implicit Euler
                method, which is simple and stable for game physics:
            </p>

            <div class="formula-box">
                <h4>Semi-Implicit Euler Integration</h4>
                <code>
Given: force F, mass m, current velocity v, current position p

Step 1: Compute acceleration from forces
    a = F / m    (Newton's second law: F = ma)

Step 2: Update velocity using acceleration
    v = v + a * dt

Step 3: Update position using NEW velocity (semi-implicit!)
    p = p + v * dt

Why "semi-implicit"? We use the updated velocity to update position.
This provides better stability than explicit Euler which uses old velocity.
                </code>
            </div>

            <p>
                Here's the actual integration code from <code>PhysicsWorld.cpp IntegratePhysics()</code>:
            </p>

            <pre><code class="language-cpp">void PhysicsWorld::IntegratePhysics(float dt) {
    auto* transformPool = m_World->GetComponentPool&lt;Transform&gt;();
    auto* rigidBodyPool = m_World->GetComponentPool&lt;RigidBody&gt;();

    if (!transformPool || !rigidBodyPool) return;

    for (Entity entity : rigidBodyPool->GetEntities()) {
        if (!m_World->HasComponent&lt;Transform&gt;(entity)) continue;

        Transform& transform = m_World->GetComponent&lt;Transform&gt;(entity);
        RigidBody& rb = m_World->GetComponent&lt;RigidBody&gt;(entity);

        // Skip static bodies (they never move)
        if (rb.type == RigidBodyType::Static) continue;

        // Apply gravity (only to dynamic bodies that want it)
        if (rb.useGravity && rb.type == RigidBodyType::Dynamic) {
            rb.force += rb.gravity * rb.mass;  // F = m * g
        }

        // Integrate velocity (only dynamic bodies respond to forces)
        if (rb.type == RigidBodyType::Dynamic && rb.mass > 0.0f) {
            glm::vec3 acceleration = rb.force / rb.mass;  // a = F / m
            rb.velocity += acceleration * dt;             // v = v + a*dt

            // Apply drag (air resistance)
            rb.velocity *= (1.0f - rb.drag * dt);
        }

        // Integrate position (both kinematic and dynamic bodies move)
        if (!rb.freezePositionX) transform.position.x += rb.velocity.x * dt;
        if (!rb.freezePositionY) transform.position.y += rb.velocity.y * dt;
        if (!rb.freezePositionZ) transform.position.z += rb.velocity.z * dt;

        // Integrate angular velocity (rotational motion)
        if (rb.type == RigidBodyType::Dynamic) {
            glm::vec3 angularAcceleration = rb.torque;  // Simplified (assumes unit inertia)
            rb.angularVelocity += angularAcceleration * dt;
            rb.angularVelocity *= (1.0f - rb.angularDrag * dt);
        }

        // Integrate rotation
        if (!rb.freezeRotationX) transform.rotation.x += glm::degrees(rb.angularVelocity.x) * dt;
        if (!rb.freezeRotationY) transform.rotation.y += glm::degrees(rb.angularVelocity.y) * dt;
        if (!rb.freezeRotationZ) transform.rotation.z += glm::degrees(rb.angularVelocity.z) * dt;

        // Clear forces (forces only last one frame, must be re-applied each frame)
        rb.force = glm::vec3(0.0f);
        rb.torque = glm::vec3(0.0f);
    }
}</code></pre>

            <h4>Forces vs Impulses - When to Use Each</h4>

            <div class="comparison-box-vertical">
                <div class="comparison-left">
                    <h4>Use Forces For...</h4>
                    <ul>
                        <li><strong>Continuous effects</strong>: Gravity, wind, thrust</li>
                        <li><strong>Gradual acceleration</strong>: Car engines, jet packs</li>
                        <li><strong>Applied every frame</strong>: Walking, swimming</li>
                    </ul>
                    <pre><code class="language-cpp">// Example: Apply thrust force
rb.AddForce(thrustDirection * thrustPower);

// Engine integrates: v += (F/m) * dt
// Force applied gradually over time</code></pre>
                </div>
                <div class="comparison-right">
                    <h4>Use Impulses For...</h4>
                    <ul>
                        <li><strong>Instant events</strong>: Collisions, explosions</li>
                        <li><strong>Immediate velocity change</strong>: Jumping, launching</li>
                        <li><strong>One-time effects</strong>: Not continuous</li>
                    </ul>
                    <pre><code class="language-cpp">// Example: Jump impulse
rb.AddImpulse(glm::vec3(0, jumpForce, 0));

// Velocity changes instantly: v += J/m
// No gradual acceleration</code></pre>
                </div>
            </div>

            <h4>Understanding Drag</h4>

            <p>
                Drag simulates air resistance and friction. It gradually slows down moving objects:
            </p>

            <div class="formula-box">
                <h4>Drag Formula</h4>
                <code>
velocity *= (1.0f - drag * dt);

Example with drag = 0.1:
    Frame 0: v = 10.0 m/s
    Frame 1: v = 10.0 * (1.0 - 0.1*0.016) = 9.984 m/s
    Frame 2: v = 9.984 * (1.0 - 0.1*0.016) = 9.968 m/s
    ...object gradually slows down

drag = 0.0: No drag (object never slows down, like space)
drag = 1.0: Very high drag (object stops in ~1 second)
drag = 10.0: Extreme drag (object stops almost instantly)
                </code>
            </div>

            <h4>Constraints - Freezing Axes</h4>

            <p>
                Sometimes you want to restrict an object's motion. The freeze flags prevent movement/rotation on specific axes:
            </p>

            <div class="physics-box">
                <h4>Common Constraint Use Cases</h4>
                <ul>
                    <li><strong>2D Game in 3D Engine</strong>: Freeze Z position and X/Y rotation</li>
                    <li><strong>Vertical-only Elevator</strong>: Freeze X and Z position, all rotations</li>
                    <li><strong>Spinning Platform</strong>: Freeze all position, freeze X and Z rotation (only Y rotation)</li>
                    <li><strong>Top-down Character</strong>: Freeze Y position (stay on ground plane)</li>
                </ul>
            </div>

            <h3>Raycasting - DETAILED</h3>

            <p>
                Raycasting is the process of shooting an invisible ray through the physics world to detect what it hits. This is
                essential for many gameplay mechanics.
            </p>

            <h4>What is Raycasting?</h4>

            <p>
                A raycast shoots an infinite (or length-limited) ray from an origin point in a direction, testing what colliders
                it intersects. Unlike collision detection which tests object-object, raycasting tests ray-object.
            </p>

            <div class="ascii-diagram">Raycast Example:

Camera/Player                     Wall
     ●                             │
      \                            │
       \   Ray                     │
        \                          │
         \                         │
          \                        │
           ●─────────────────────→ ●  Hit!
         origin              hitPoint
                                   │

The ray starts at origin, travels in direction,
and reports the first object it hits.</div>

            <h4>Ray Structure</h4>

            <p>
                A ray is defined by an origin point and a direction vector:
            </p>

            <pre><code class="language-cpp">// Ray structure from Engine/Physics/Collider.h
struct Ray {
    glm::vec3 origin = glm::vec3(0.0f);              // Starting point
    glm::vec3 direction = glm::vec3(0.0f, 0.0f, -1.0f);  // Direction (normalized!)

    Ray() = default;
    Ray(const glm::vec3& o, const glm::vec3& d)
        : origin(o), direction(glm::normalize(d)) {}  // Auto-normalize direction

    // Get a point along the ray at distance t
    glm::vec3 GetPoint(float t) const {
        return origin + direction * t;
    }
};</code></pre>

            <div class="formula-box">
                <h4>Parametric Ray Equation</h4>
                <code>
A ray is defined parametrically as:
    P(t) = origin + direction * t

Where t is a parameter (distance along ray):
    t = 0: P(0) = origin (ray starts here)
    t = 1: P(1) = origin + direction (1 unit along ray)
    t = 5: P(5) = origin + 5*direction (5 units along ray)

For raycasting, we find the smallest t > 0 where ray intersects an object.
                </code>
            </div>

            <h4>Ray-AABB Intersection - The Slab Method</h4>

            <p>
                The slab method is an elegant algorithm for ray-AABB intersection. It treats the AABB as the intersection of
                three "slabs" (infinite planes perpendicular to X, Y, Z axes):
            </p>

            <pre><code class="language-cpp">bool PhysicsWorld::TestRayAABB(const Ray& ray, const AABB& aabb, float& tMin, float& tMax) {
    tMin = 0.0f;
    tMax = std::numeric_limits&lt;float&gt;::max();

    // Test intersection with each axis slab
    for (int i = 0; i < 3; i++) {
        float origin = ray.origin[i];
        float dir = ray.direction[i];
        float minB = aabb.min[i];
        float maxB = aabb.max[i];

        // Ray parallel to slab planes?
        if (std::abs(dir) < 0.0001f) {
            // Ray parallel to slab - check if origin is inside slab
            if (origin < minB || origin > maxB) return false;
        } else {
            // Compute intersection distances with slab planes
            float t1 = (minB - origin) / dir;
            float t2 = (maxB - origin) / dir;

            // Ensure t1 is entry, t2 is exit
            if (t1 > t2) std::swap(t1, t2);

            // Update overall entry/exit distances
            tMin = glm::max(tMin, t1);
            tMax = glm::min(tMax, t2);

            // Ray misses AABB if entry is after exit
            if (tMin > tMax) return false;
        }
    }

    return true;
}</code></pre>

            <h4>Understanding the Slab Method</h4>

            <div class="ascii-diagram">Slab Method Visualization (2D):

Y-axis slab:
  ══════════════════════ maxB.y
      Ray hits here at t2
  ──────────●───────────
           /
          / Ray
         /
  ──────●───────────────
     Ray enters at t1
  ══════════════════════ minB.y

X-axis slab:
  │                    │
  │                    │
  │  Ray enters at t3  │ Ray exits at t4
  │    ●──────────────●│
  │   /                │
  │  /                 │
 minB.x              maxB.x

Final intersection:
  tMin = max(t1, t3) = when ray enters AABB
  tMax = min(t2, t4) = when ray exits AABB

If tMin > tMax, ray misses AABB entirely.</div>

            <p>
                The beauty of this algorithm is that it works in any number of dimensions and handles all edge cases
                (ray parallel to faces, ray origin inside box, etc.) with the same simple logic.
            </p>

            <h4>Ray-Sphere Intersection - The Quadratic Equation</h4>

            <p>
                Ray-sphere intersection uses analytical geometry. We solve for where the ray equation intersects the sphere equation:
            </p>

            <div class="formula-box">
                <h4>Ray-Sphere Math</h4>
                <code>
Sphere equation: ||P - C||² = r²  (all points at distance r from center C)
Ray equation:    P(t) = O + tD     (O = origin, D = direction)

Substitute ray into sphere:
    ||O + tD - C||² = r²

Let oc = O - C (vector from sphere center to ray origin):
    ||oc + tD||² = r²

Expand dot product:
    (oc + tD)·(oc + tD) = r²
    oc·oc + 2t(oc·D) + t²(D·D) = r²

Rearrange into standard quadratic form at² + bt + c = 0:
    a = D·D
    b = 2(oc·D)
    c = oc·oc - r²

Solve using quadratic formula:
    discriminant = b² - 4ac

    If discriminant < 0: No intersection (ray misses sphere)
    If discriminant = 0: One intersection (ray grazes sphere)
    If discriminant > 0: Two intersections (ray enters and exits sphere)

    t = (-b ± √discriminant) / 2a

We want the smallest positive t (closest hit point).
                </code>
            </div>

            <pre><code class="language-cpp">bool PhysicsWorld::TestRaySphere(const Ray& ray, const BoundingSphere& sphere, float& t) {
    // Vector from sphere center to ray origin
    glm::vec3 oc = ray.origin - sphere.center;

    // Quadratic coefficients (a = 1 because direction is normalized)
    float a = glm::dot(ray.direction, ray.direction);
    float b = 2.0f * glm::dot(oc, ray.direction);
    float c = glm::dot(oc, oc) - sphere.radius * sphere.radius;

    // Discriminant
    float discriminant = b * b - 4 * a * c;

    // No intersection if discriminant is negative
    if (discriminant < 0) return false;

    // Compute nearest intersection (smallest positive t)
    t = (-b - std::sqrt(discriminant)) / (2.0f * a);

    // Return true only if intersection is in front of ray (t >= 0)
    return t >= 0;
}</code></pre>

            <h4>Raycasting Use Cases</h4>

            <div class="physics-box">
                <h4>Common Raycasting Applications</h4>
                <ul>
                    <li><strong>Mouse Picking</strong>: Cast ray from camera through mouse cursor to select objects in 3D</li>
                    <li><strong>Shooting Mechanics</strong>: Cast ray from gun barrel to detect what was hit</li>
                    <li><strong>Line of Sight</strong>: Can enemy see player? Cast ray and check for obstacles</li>
                    <li><strong>Ground Detection</strong>: Cast ray downward from character to find floor height</li>
                    <li><strong>AI Pathfinding</strong>: Cast rays to detect walls and obstacles</li>
                    <li><strong>Laser Sights</strong>: Cast ray and draw line to hit point</li>
                </ul>
            </div>

            <pre><code class="language-cpp">// Example: Mouse picking
Ray CameraToMouseRay(Camera& cam, glm::vec2 mousePos, glm::vec2 screenSize) {
    // Convert screen coordinates to NDC
    float x = (2.0f * mousePos.x) / screenSize.x - 1.0f;
    float y = 1.0f - (2.0f * mousePos.y) / screenSize.y;

    // Unproject to world space
    glm::vec4 rayClip = glm::vec4(x, y, -1.0, 1.0);
    glm::vec4 rayEye = glm::inverse(cam.projection) * rayClip;
    rayEye = glm::vec4(rayEye.x, rayEye.y, -1.0, 0.0);
    glm::vec3 rayWorld = glm::normalize(glm::vec3(glm::inverse(cam.view) * rayEye));

    return Ray(cam.position, rayWorld);
}

// Cast ray and find hit
RaycastHit hit = physics.Raycast(ray, maxDistance);
if (hit.hit) {
    // Do something with hit.entity, hit.point, hit.normal, hit.distance
    SelectObject(hit.entity);
}</code></pre>

            <h3>Putting It All Together: The Physics System</h3>

            <p>
                Now that we understand each component, let's see how they work together in the complete physics simulation loop:
            </p>

            <pre><code class="language-cpp">void PhysicsWorld::Step(float dt) {
    if (!m_World) return;

    // 1. Integration: Apply forces and update positions
    IntegratePhysics(dt);

    // 2. Collision Detection: Find all colliding pairs
    DetectCollisions();

    // 3. Collision Response: Separate and apply impulses
    ResolveCollisions();
}

// Called from game loop with fixed timestep
const float PHYSICS_DT = 1.0f / 60.0f;
float accumulator = 0.0f;

void Update(float deltaTime) {
    accumulator += deltaTime;

    while (accumulator >= PHYSICS_DT) {
        physics.Step(PHYSICS_DT);
        accumulator -= PHYSICS_DT;
    }
}</code></pre>

            <div class="physics-box">
                <h4>Performance Considerations</h4>
                <p>
                    Physics is expensive. For a game with 100 dynamic objects:
                </p>
                <ul>
                    <li><strong>Integration</strong>: O(n) = 100 operations (cheap)</li>
                    <li><strong>Broad Phase</strong>: O(n²) = 10,000 pairs to check (expensive!)</li>
                    <li><strong>Narrow Phase</strong>: O(m) where m = actual collision pairs (cheap per pair)</li>
                    <li><strong>Resolution</strong>: O(m) (cheap per pair)</li>
                </ul>
                <p>
                    The broad phase dominates performance. This is why production engines use spatial partitioning (BVH, grid, etc.)
                    to reduce O(n²) to O(n log n) or even O(n).
                </p>
            </div>

            <div class="tip-box">
                <h4>Next Steps for Learning Physics</h4>
                <ul>
                    <li>Implement spatial partitioning (grid or BVH) to optimize broad phase</li>
                    <li>Add oriented bounding boxes (OBB) for rotated objects</li>
                    <li>Implement proper friction using Coulomb model</li>
                    <li>Add joints and constraints (hinges, springs, ragdolls)</li>
                    <li>Study continuous collision detection (CCD) to prevent tunneling</li>
                    <li>Read <em>"Game Physics Engine Development"</em> by Ian Millington</li>
                    <li>Study Box2D source code (excellent 2D physics implementation)</li>
                </ul>
            </div>
        </section>

        <section id="audio">
            <h2>Audio System: Sound and Music</h2>

            <h3>Audio Engine Architecture</h3>

            <p>
                The audio system handles:
            </p>

            <ul>
                <li><strong>Sound Sources</strong>: 2D (UI sounds) and 3D (world sounds with position)</li>
                <li><strong>Listener</strong>: Player's ear position (usually camera position)</li>
                <li><strong>Mixing</strong>: Combine multiple sounds, apply volume/effects</li>
                <li><strong>Streaming</strong>: Music files too large to fit in memory</li>
            </ul>

            <div class="concept-box">
                <h4>3D Audio Spatialization</h4>
                <p>
                    3D audio simulates how sound changes based on position:
                </p>
                <pre><code class="language-plaintext">// Distance attenuation (inverse square law):
volume = baseVolume / (1.0 + distance * distance);

// Panning (left/right balance):
float angle = atan2(soundPos.z - listenerPos.z, soundPos.x - listenerPos.x);
leftVolume = volume * (1.0 - (angle / PI));
rightVolume = volume * (1.0 + (angle / PI));

// Doppler effect (pitch shift):
float relativeVelocity = dot(soundVelocity - listenerVelocity, direction);
pitch = 1.0 + (relativeVelocity / speedOfSound);</code></pre>
            </div>

            <h3>Integration with ECS</h3>

            <pre><code class="language-cpp">struct AudioSource {
    std::shared_ptr&lt;AudioClip&gt; clip;
    float volume = 1.0f;
    float pitch = 1.0f;
    bool loop = false;
    bool is3D = true;
    float minDistance = 1.0f;
    float maxDistance = 100.0f;
};

// AudioSystem updates 3D audio sources:
world.ForEach&lt;Transform, AudioSource&gt;([](Entity e, Transform& t, AudioSource& audio) {
    if (audio.is3D) {
        audio.SetPosition(t.position);
        audio.UpdateAttenuation(listenerPosition);
    }
});</code></pre>
        </section>

        <section id="editor">
            <h2>Editor Integration: Tools for Creators</h2>

            <h3>ImGui for Editor UI</h3>

            <p>
                ImGui (Immediate Mode GUI) is perfect for editor interfaces. Unlike retained-mode GUIs (Qt, WPF), you don't
                manage widget state - you just call functions each frame:
            </p>

            <pre><code class="language-cpp">// Immediate mode - no state management needed:
void OnImGui() {
    ImGui::Begin("Inspector");

    if (selectedEntity != INVALID_ENTITY) {
        // Entity name
        static char nameBuffer[256];
        strcpy(nameBuffer, world.GetEntityName(selectedEntity).c_str());
        if (ImGui::InputText("Name", nameBuffer, 256)) {
            world.SetEntityName(selectedEntity, nameBuffer);
        }

        // Transform component
        if (world.HasComponent&lt;Transform&gt;(selectedEntity)) {
            Transform& t = world.GetComponent&lt;Transform&gt;(selectedEntity);
            ImGui::DragFloat3("Position", &t.position.x, 0.1f);
            ImGui::DragFloat3("Rotation", &t.rotation.x, 1.0f);
            ImGui::DragFloat3("Scale", &t.scale.x, 0.1f);
        }

        // Add component button
        if (ImGui::Button("Add Component")) {
            ImGui::OpenPopup("ComponentMenu");
        }
        if (ImGui::BeginPopup("ComponentMenu")) {
            if (ImGui::MenuItem("Mesh Renderer")) {
                world.AddComponent&lt;MeshRenderer&gt;(selectedEntity);
            }
            if (ImGui::MenuItem("Rigid Body")) {
                world.AddComponent&lt;RigidBody&gt;(selectedEntity);
            }
            ImGui::EndPopup();
        }
    }

    ImGui::End();
}</code></pre>

            <h3>Scene Serialization</h3>

            <p>
                Saving and loading scenes requires serializing the ECS state:
            </p>

            <pre><code class="language-plaintext">// JSON format:
{
    "entities": [
        {
            "id": 0,
            "name": "Player",
            "components": {
                "Transform": {
                    "position": [0, 1, 0],
                    "rotation": [0, 0, 0],
                    "scale": [1, 1, 1]
                },
                "MeshRenderer": {
                    "mesh": "assets/player.obj",
                    "material": "assets/player_mat.json"
                }
            }
        }
    ]
}</code></pre>

            <p>
                Component serialization uses reflection or manual serialization functions for each component type.
            </p>
        </section>

        <section id="game-loop">
            <h2>Putting It All Together: The Game Loop</h2>

            <h3>Application Architecture</h3>

            <pre><code class="language-cpp">#pragma once

#include "Window.h"
#include &lt;memory&gt;

namespace Xi {

    class World;
    class Renderer;
    class PhysicsWorld;
    class AudioEngine;
    class EditorUI;
    class ScriptEngine;

    class Application {
    public:
        Application(const WindowProps& props = WindowProps());
        virtual ~Application();

        void Run();  // Main loop
        void Quit();

        // Accessors
        Window& GetWindow() { return *m_Window; }
        World& GetWorld() { return *m_World; }
        Renderer& GetRenderer() { return *m_Renderer; }

        static Application& Get() { return *s_Instance; }

    protected:
        // Override these in your game
        virtual void OnInit() {}
        virtual void OnUpdate(float dt) {}
        virtual void OnFixedUpdate(float dt) {}
        virtual void OnRender() {}
        virtual void OnImGui() {}
        virtual void OnShutdown() {}

    private:
        void Init();
        void MainLoop();
        void Shutdown();

        std::unique_ptr&lt;Window&gt; m_Window;
        std::unique_ptr&lt;World&gt; m_World;
        std::unique_ptr&lt;Renderer&gt; m_Renderer;
        std::unique_ptr&lt;PhysicsWorld&gt; m_Physics;
        std::unique_ptr&lt;AudioEngine&gt; m_Audio;
        std::unique_ptr&lt;EditorUI&gt; m_Editor;
        std::unique_ptr&lt;ScriptEngine&gt; m_ScriptEngine;

        bool m_Running = true;

        static Application* s_Instance;
    };

}</code></pre>

            <h3>The Game Loop Explained</h3>

            <p>
                The game loop is the heart of the engine - it runs every frame and orchestrates all systems:
            </p>

            <pre><code class="language-cpp">void Application::MainLoop() {
    // Timing
    float lastFrameTime = GetTime();
    float accumulator = 0.0f;
    const float fixedDeltaTime = 1.0f / 60.0f;  // 60 FPS physics

    while (m_Running) {
        // Calculate delta time
        float currentTime = GetTime();
        float deltaTime = currentTime - lastFrameTime;
        lastFrameTime = currentTime;

        // Clamp delta time to prevent spiral of death
        if (deltaTime > 0.25f) deltaTime = 0.25f;

        accumulator += deltaTime;

        // Process input
        m_Window->PollEvents();

        // Fixed timestep physics (may run 0, 1, or multiple times)
        while (accumulator >= fixedDeltaTime) {
            OnFixedUpdate(fixedDeltaTime);
            m_Physics->Step(fixedDeltaTime);
            accumulator -= fixedDeltaTime;
        }

        // Variable timestep game logic
        OnUpdate(deltaTime);
        m_World->Update(deltaTime);

        // Rendering
        m_Renderer->BeginFrame();
        OnRender();
        m_World->Render(*m_Renderer);

        // Editor UI
        if (m_EditorMode) {
            m_Editor->Begin();
            OnImGui();
            m_Editor->Render();
            m_Editor->End();
        }

        m_Renderer->EndFrame();
        m_Window->SwapBuffers();
    }
}</code></pre>

            <div class="concept-box">
                <h4>Fixed vs Variable Timestep</h4>
                <p>
                    <strong>Fixed Timestep</strong> (physics): Always runs with the same delta time (e.g., 1/60 second). This ensures
                    physics simulation is deterministic and stable. On slow hardware, physics may run multiple times per frame. On
                    fast hardware, it may skip frames.
                </p>
                <p>
                    <strong>Variable Timestep</strong> (rendering/logic): Uses actual time elapsed since last frame. This makes rendering
                    smooth but can cause issues if delta time varies wildly (hence the clamp to 0.25s).
                </p>
                <p>
                    The accumulator pattern (also called "Fix Your Timestep" by Glenn Fiedler) is the industry standard for game loops.
                </p>
            </div>

            <h3>Frame Time Budget</h3>

            <p>
                For 60 FPS, you have 16.67ms per frame. A typical breakdown:
            </p>

            <pre><code class="language-plaintext">Frame Budget (16.67ms total):
- Input:        0.5ms
- Physics:      3.0ms
- Game Logic:   2.0ms
- Animation:    1.0ms
- Rendering:    8.0ms
  - Culling:    1.0ms
  - Sorting:    0.5ms
  - Draw calls: 4.0ms
  - GPU wait:   2.5ms
- Audio:        0.5ms
- Editor UI:    1.0ms
- Misc:         0.67ms

If you exceed 16.67ms, frame rate drops.</code></pre>

            <h3>Putting It All Together</h3>

            <p>
                Here's how all the systems we've built work together in a single frame:
            </p>

            <pre><code class="language-glsl">Frame N begins:
1. Input System reads keyboard/mouse state
2. Script System executes OnUpdate() in all script components
3. AI System updates enemy behavior
4. Animation System updates bone transforms
5. Physics System:
   a. Broad phase collision detection
   b. Narrow phase collision detection
   c. Constraint solver (collisions, joints)
   d. Integration (update positions/velocities)
6. Transform System updates world matrices from local transforms
7. Camera System updates view/projection matrices
8. Renderer:
   a. Frustum culling (remove invisible objects)
   b. Sort by material (minimize state changes)
   c. Submit draw calls to GPU
   d. GPU executes vertex/fragment shaders
9. Audio System updates 3D sound positions
10. Editor UI renders ImGui windows
11. Swap buffers (display rendered frame)

Frame N+1 begins...</code></pre>

            <h3>Creating Your First Game</h3>

            <pre><code class="language-cpp">// MyGame.h
class MyGame : public Xi::Application {
public:
    MyGame() : Application() {}

protected:
    void OnInit() override {
        // Create a player entity
        auto player = GetWorld().CreateEntity("Player");
        auto& transform = GetWorld().AddComponent&lt;Transform&gt;(player);
        transform.position = glm::vec3(0, 1, 0);

        auto& mesh = GetWorld().AddComponent&lt;MeshRenderer&gt;(player);
        mesh.mesh = MeshLoader::LoadFromFile("assets/player.obj");
        mesh.material = std::make_shared&lt;Material&gt;();
        mesh.material->shader = GetRenderer().GetDefaultShader();

        auto& rb = GetWorld().AddComponent&lt;RigidBody&gt;(player);
        rb.mass = 1.0f;

        // Load a script
        auto scriptSystem = GetWorld().GetSystem&lt;ScriptSystem&gt;();
        scriptSystem->LoadScript(player, "scripts/player.lua");
    }

    void OnUpdate(float dt) override {
        // Game-specific logic here
    }
};

// main.cpp
int main() {
    MyGame game;
    game.Run();
    return 0;
}</code></pre>

            <div class="concept-box">
                <h4>Next Steps</h4>
                <p>
                    You've now learned the fundamentals of game engine architecture:
                </p>
                <ul>
                    <li>ECS for data-oriented design</li>
                    <li>Scripting for rapid iteration</li>
                    <li>PBR rendering for realistic graphics</li>
                    <li>Physics for realistic interaction</li>
                    <li>Editor tools for productivity</li>
                </ul>
                <p>
                    To continue learning:
                </p>
                <ul>
                    <li>Read "Game Engine Architecture" by Jason Gregory</li>
                    <li>Study open-source engines (Godot, Hazel)</li>
                    <li>Implement advanced features (shadow mapping, post-processing, particles)</li>
                    <li>Optimize using profilers (what you measure, you can improve)</li>
                    <li>Build games with your engine (nothing teaches like real use cases)</li>
                </ul>
            </div>
        </section>

        <section id="game-development">
            <h2>Game Development with Lua Scripting</h2>

            <p>
                Xi Engine features full Lua scripting support, allowing you to write gameplay logic without recompiling the engine.
                Scripts are attached to entities and can control movement, respond to input, handle collisions, and implement game mechanics.
            </p>

            <h3 id="lua-basics">Lua Scripting Basics</h3>

            <p>
                Lua is a lightweight, embeddable scripting language with simple syntax. In Xi Engine, each entity can have a script
                that defines its behavior through callback functions:
            </p>

            <pre><code class="language-lua">-- Basic script structure
local speed = 5.0  -- Local variables

-- Called once when the entity is created
function OnStart()
    Log.Info("Entity started!")
end

-- Called every frame
-- dt = delta time (time since last frame in seconds)
function OnUpdate(dt)
    -- Update logic here
end

-- Called when this entity collides with another
function OnCollision(other)
    Log.Info("Collision detected!")
end</code></pre>

            <div class="concept-box">
                <h4>Script Lifecycle</h4>
                <ol>
                    <li><strong>OnStart()</strong>: Called once when the script initializes</li>
                    <li><strong>OnUpdate(dt)</strong>: Called every frame with delta time</li>
                    <li><strong>OnCollision(other)</strong>: Called when collision occurs</li>
                </ol>
            </div>

            <h3 id="entity-scripting">Entity Scripts</h3>

            <p>
                Scripts have access to entity transform functions to move and manipulate objects in the world:
            </p>

            <pre><code class="language-lua">-- Transform functions available in scripts

-- Translation (movement)
Translate(x, y, z)          -- Move relative to current position
SetPosition(x, y, z)        -- Set absolute world position
GetPosition()               -- Returns current position

-- Rotation
Rotate(angleX, angleY, angleZ)  -- Rotate in degrees
SetRotation(x, y, z)            -- Set absolute rotation
GetRotation()                   -- Returns current rotation

-- Scale
SetScale(x, y, z)           -- Set object scale
GetScale()                  -- Returns current scale</code></pre>

            <h4>Example: Rotating Object</h4>

            <pre><code class="language-lua">-- Rotate object continuously
local rotationSpeed = 90  -- degrees per second

function OnUpdate(dt)
    -- Rotate around Y axis
    Rotate(0, rotationSpeed * dt, 0)
end</code></pre>

            <h3 id="input-handling">Input Handling</h3>

            <p>
                The Input API provides access to keyboard, mouse, and game controller input:
            </p>

            <pre><code class="language-lua">-- Input API Reference

-- Keyboard
Input.IsKeyDown(Key.W)      -- Returns true while key is held
Input.IsKeyPressed(Key.W)   -- Returns true once when key is pressed
Input.IsKeyReleased(Key.W)  -- Returns true once when key is released

-- Common key codes:
-- Key.W, Key.A, Key.S, Key.D
-- Key.Space, Key.LeftShift, Key.LeftControl
-- Key.Escape, Key.Enter
-- Key.Up, Key.Down, Key.Left, Key.Right

-- Mouse
Input.GetMouseX()           -- Get mouse X position
Input.GetMouseY()           -- Get mouse Y position
Input.IsMouseButtonDown(0)  -- Left mouse button (0=left, 1=right, 2=middle)</code></pre>

            <h4>Example: WASD Movement</h4>

            <pre><code class="language-lua">-- Player movement script
local speed = 5  -- units per second

function OnStart()
    Log.Info("Movement enabled - use WASD")
end

function OnUpdate(dt)
    local moveSpeed = speed * dt

    -- Forward/Backward
    if Input.IsKeyDown(Key.W) then
        Translate(0, 0, -moveSpeed)
    end

    if Input.IsKeyDown(Key.S) then
        Translate(0, 0, moveSpeed)
    end

    -- Left/Right
    if Input.IsKeyDown(Key.A) then
        Translate(-moveSpeed, 0, 0)
    end

    if Input.IsKeyDown(Key.D) then
        Translate(moveSpeed, 0, 0)
    end

    -- Up/Down
    if Input.IsKeyDown(Key.Space) then
        Translate(0, moveSpeed, 0)
    end

    if Input.IsKeyDown(Key.LeftShift) then
        Translate(0, -moveSpeed, 0)
    end
end</code></pre>

            <h3 id="game-examples">Complete Game Examples</h3>

            <h4>Example 1: Simple Bouncing Ball</h4>

            <pre><code class="language-lua">-- Bouncing ball that reverses direction when reaching boundaries
local velocity = {x = 2, y = 3, z = 0}
local bounds = 10  -- Boundary limit

function OnUpdate(dt)
    -- Get current position
    local pos = GetPosition()

    -- Update position
    pos.x = pos.x + velocity.x * dt
    pos.y = pos.y + velocity.y * dt

    -- Bounce off boundaries
    if pos.x > bounds or pos.x < -bounds then
        velocity.x = -velocity.x
    end

    if pos.y > bounds or pos.y < -bounds then
        velocity.y = -velocity.y
    end

    -- Apply new position
    SetPosition(pos.x, pos.y, pos.z)
end</code></pre>

            <h4>Example 2: Follow Camera</h4>

            <pre><code class="language-lua">-- Camera that follows a target at a distance
local target = "Player"  -- Entity name to follow
local followDistance = 10
local followHeight = 5
local smoothSpeed = 5

function OnUpdate(dt)
    -- Note: This is a simplified example
    -- In a real implementation, you'd get the target entity's position

    local targetPos = GetPosition()  -- Would get target entity position

    -- Calculate desired camera position
    local desiredX = targetPos.x
    local desiredY = targetPos.y + followHeight
    local desiredZ = targetPos.z + followDistance

    -- Get current position
    local currentPos = GetPosition()

    -- Smoothly interpolate to desired position
    local newX = currentPos.x + (desiredX - currentPos.x) * smoothSpeed * dt
    local newY = currentPos.y + (desiredY - currentPos.y) * smoothSpeed * dt
    local newZ = currentPos.z + (desiredZ - currentPos.z) * smoothSpeed * dt

    SetPosition(newX, newY, newZ)
end</code></pre>

            <h4>Example 3: Collectible Item</h4>

            <pre><code class="language-lua">-- Collectible item that rotates and responds to player collision
local rotationSpeed = 180  -- degrees per second
local bobSpeed = 2
local bobHeight = 0.5
local initialY = 0
local time = 0

function OnStart()
    local pos = GetPosition()
    initialY = pos.y
    Log.Info("Collectible spawned")
end

function OnUpdate(dt)
    time = time + dt

    -- Rotate the item
    Rotate(0, rotationSpeed * dt, 0)

    -- Bob up and down
    local pos = GetPosition()
    local bobOffset = math.sin(time * bobSpeed) * bobHeight
    SetPosition(pos.x, initialY + bobOffset, pos.z)
end

function OnCollision(other)
    -- When player collects this item
    Log.Info("Item collected!")
    -- In a real game, you would:
    -- 1. Add points/resources to player
    -- 2. Play a sound effect
    -- 3. Destroy this entity
end</code></pre>

            <h4>Example 4: Enemy AI</h4>

            <pre><code class="language-lua">-- Simple enemy that patrols between two points
local patrolPoints = {
    {x = -5, y = 0, z = 0},
    {x = 5, y = 0, z = 0}
}
local currentTarget = 1
local moveSpeed = 3
local reachedThreshold = 0.5  -- Distance to consider "reached"

function OnStart()
    Log.Info("Enemy patrol started")
end

function OnUpdate(dt)
    local pos = GetPosition()
    local target = patrolPoints[currentTarget]

    -- Calculate direction to target
    local dx = target.x - pos.x
    local dz = target.z - pos.z
    local distance = math.sqrt(dx * dx + dz * dz)

    if distance < reachedThreshold then
        -- Reached target, switch to other patrol point
        if currentTarget == 1 then
            currentTarget = 2
        else
            currentTarget = 1
        end
    else
        -- Move towards target
        local dirX = dx / distance
        local dirZ = dz / distance

        Translate(dirX * moveSpeed * dt, 0, dirZ * moveSpeed * dt)
    end
end

function OnCollision(other)
    Log.Info("Enemy collided with: " .. other)
    -- Implement damage logic here
end</code></pre>

            <div class="concept-box">
                <h4>Best Practices for Game Scripts</h4>
                <ul>
                    <li><strong>Use local variables</strong>: They're faster and avoid global namespace pollution</li>
                    <li><strong>Cache calculations</strong>: Don't recalculate the same values every frame</li>
                    <li><strong>Use delta time</strong>: Multiply movement by dt to make it frame-rate independent</li>
                    <li><strong>Initialize in OnStart()</strong>: Set up initial state once, not every frame</li>
                    <li><strong>Keep OnUpdate() fast</strong>: It runs every frame, so optimize heavily-used code</li>
                    <li><strong>Comment your code</strong>: Explain what your script does and why</li>
                </ul>
            </div>

            <h4>Debugging Scripts</h4>

            <pre><code class="language-lua">-- Use Log functions to debug your scripts

function OnUpdate(dt)
    -- Print information to console
    Log.Info("Current position: " .. GetPosition().x)

    -- Print warnings
    if GetPosition().y < 0 then
        Log.Warning("Entity fell below ground!")
    end

    -- Print errors for critical issues
    if not Input then
        Log.Error("Input system not available!")
    end
end</code></pre>

            <h4>Loading Scripts in the Editor</h4>

            <p>
                To attach a script to an entity in the Xi Engine editor:
            </p>

            <ol>
                <li>Select an entity in the Scene Hierarchy</li>
                <li>In the Inspector panel, find the Script component</li>
                <li>Click "Edit Script" to open the script editor</li>
                <li>Write your Lua code</li>
                <li>Click "Compile" to check for syntax errors</li>
                <li>Click "Save" to apply the script to the entity</li>
                <li>Click "Play" to test your game</li>
            </ol>

            <p>
                The script editor features syntax highlighting and will show compilation errors to help you write correct code.
            </p>
        </section>

        <section>
            <h2>Conclusion</h2>

            <p>
                Building a game engine from scratch is a journey of understanding. You've learned how modern engines organize code
                (ECS), manage memory (data-oriented design), enable iteration (scripting), render realistically (PBR), simulate physics,
                and provide tools (editor).
            </p>

            <p>
                More importantly, you've learned <strong>why</strong> these decisions are made. The diamond problem of inheritance
                explains why ECS exists. Cache-friendly data layouts explain why component pools use contiguous arrays. Energy conservation
                explains why PBR looks more realistic than Phong shading.
            </p>

            <p>
                The Xi Engine is a learning tool, not a production engine. Real engines add countless features we haven't covered:
                asset streaming, multithreading, networking, advanced rendering techniques (deferred shading, global illumination),
                and much more. But the principles remain the same.
            </p>

            <p>
                Now go build something amazing. The best way to learn is to create.
            </p>
        </section>
    </div>

    <script src="script.js"></script>
</body>
</html>
